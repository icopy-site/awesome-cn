<div class="github-widget" data-repo="stn1slv/awesome-integration"></div>
## Awesome Integration [![Awesome](https://awesome.re/badge.svg)](https://awesome.re) [![Track Awesome List](https://www.trackawesomelist.com/badge.svg)](https://www.trackawesomelist.com/stn1slv/awesome-integration/week/)

&gt; 精选的系统集成软件、模式和资源列表.

系统集成是将不同的 IT 系统（组件）链接在一起以作为一个整体进行功能协作的过程.

  - [Data Mapping Solution](#data-mapping-solution) 
  - [iPaaS](#ipaas)  
  - [Enterprise Integration Patterns](#enterprise-integration-patterns) 
  - [API Specification](#api-specification) 

---
## Projects
### API Management
 *API 管理解决方案提供了一种处理整个 API 生命周期的综合方法. 它们使开发人员能够创建、发布、保护和监控 API，确保系统之间高效可靠的通信. 这些工具具有身份验证、速率限制和分析等功能，可提供集中控制和增强的安全性，从而更轻松地跨不同平台和环境管理和扩展 API.*
- [Akana API Management Platform](https://www.akana.com/products/api-platform) - 一个综合平台，可加速数字化转型，管理完整的 API 生命周期，并在跨多个云部署时确保合规性.
- [Anypoint Platform](https://www.mulesoft.com/platform/api/manager) - 来自 Mulesoft 的单一统一平台，结合了 API 管理和集成功能，让您可以轻松设计、构建和管理 API.
- [Amazon API Management](https://aws.amazon.com/api-gateway/api-management/) - 一种安全且可扩展的 API 管理解决方案，使您能够以灵活高效的方式监控和管理 API.
- [Amplify API Management Platform](https://www.axway.com/en/products/amplify-api-management-platform) - 来自 Axway 的 API 管理开放平台，提供全面的 API 管理能力，让您轻松构建、运行和管理 API.
- [Apigee](https://cloud.google.com/apigee) - 来自 Google 的领先 API 管理解决方案，提供全面的 API 管理功能，可帮助您轻松创建、保护和扩展 API.
- [Azure API Management](https://azure.microsoft.com/en-us/services/api-management/) - 适用于所有环境的 API 的混合多云管理平台，使您能够轻松管理 API、保护它们并深入了解它们的性能.
- [DigitMarket API Manager](https://www.torryharris.com/products/digitmarket-api-manager-for-api-management) - A complete package from Torry Harris that helps you manage your APIs and turn them into tools that can drive your business forward.
- [Gravitee.io API Management](https://www.gravitee.io/products/api-management) - 灵活、轻量、开源的API管理解决方案，提供全面的API管理能力，帮助您轻松管理API.
- [IBM API Connect](https://www.ibm.com/cloud/api-connect) - 一个完整、直观且可扩展的 API 平台，允许您跨云创建、公开、管理 API 并从中获利.
- [Kong Enterprise](https://konghq.com/products/kong-enterprise) - 全面的服务连接平台，提供丰富的API管理能力，让您轻松管理API、微服务和服务网格.
- [Layer7 API Management](https://www.broadcom.com/products/software/api-management) - 来自 Broadcom 的持续 API 管理解决方案，提供全面的 API 管理功能并帮助您在 API 的整个生命周期内对其进行管理.
- [Red Hat 3scale API Management](https://www.redhat.com/en/technologies/jboss-middleware/3scale) - 一个云原生的API管理方案，简化API的开发，让API更加灵活.
- [Sensedia API Management](https://www.sensedia.com/api-management-platform) - 全生命周期API管理平台，提供完善的API管理能力，帮助您对API进行全生命周期管理.
- [TIBCO Cloud Mashery](https://www.tibco.com/products/api-management) - 来自 TIBCO 的云原生 API 平台，使您能够在任何地方部署 API 并从任何地方管理它们.
- [Tyk API Management](https://tyk.io/api-lifecycle-management/) - 强大的 API 管理解决方案，让您轻松连接、构建和控制 API.
- [webMethods API](https://www.softwareag.cloud/site/product/webmethods-api.html) - 来自 Software AG 的全面 API 管理解决方案，提供完整的生命周期 API 管理功能，使您能够在本地和云环境中管理 API.
- [WSO2 API Manager](https://github.com/wso2/product-apim) - 完全开源的API管理平台，提供全面的API管理能力，让您轻松管理API.

<!--lint disable-->
<!--lint enable-->
### API Design
 *API 设计、文档和生命周期自动化工具简化了创建、维护和发展 API 的过程. 这些工具提供了有效的方法来设计一致且可扩展的 API、生成全面的文档并自动化 API 生命周期的各个阶段，从而增强开发人员体验并促进 API 的采用.*
- [Dredd](https://github.com/apiaryio/dredd) - 使用这种与语言无关的 CLI 工具针对后端实现验证 API 描述文档.
- [OpenAPI-GUI](https://github.com/Mermade/openapi-gui) - 使用这个直观的图形用户界面轻松创建和验证 OpenAPI 规范.
- [OpenAPI Diff](https://github.com/OpenAPITools/openapi-diff) - 将 OpenAPI 规范与版本控制进行比较，并可视化 HTML 或 Markdown 格式的差异.
- [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) - 使用这个强大的 OpenAPI 规范工具自动创建 API 客户端库、服务器存根、文档和配置文件.
- [OpenAPI Style Validator](https://github.com/OpenAPITools/openapi-style-validator) - 使用这种灵活且可自定义的样式验证器，确保您的 OpenAPI 规范符合您组织的标准.
- [Spectral](https://github.com/stoplightio/spectral) - 使用此支持 OpenAPI 3.0 和 2.0 以及 AsyncAPI 的 linter 工具检测并修复 JSON/YAML 文件中的错误.
- [Swagger Editor](https://github.com/swagger-api/swagger-editor) - 使用专为基于 OpenAPI 的 API 构建的开源编辑器轻松创建、描述和记录您的 API.
- [Zally](https://github.com/zalando/zally) - 使用此提供广泛分析和反馈的 linter 工具确保您的 OpenAPI 规范的质量.

<!--lint disable-->
<!--lint enable-->
### API Documentation
 *探索旨在创建、维护和呈现清晰、简明和用户友好的 API 文档的工具和平台集合. 这些资源促进了开发人员之间的无缝协作，并实现了 API 功能和规范的有效沟通.*
- [APITree](https://www.apitree.com/) - 用于管理和共享 API 规范的工具，具有版本控制、API 测试自动化以及与流行的 API 工具的集成.
- [DapperDox](https://github.com/DapperDox/dapperdox) - 用于 OpenAPI/Swagger 规范的开源 API 文档生成器和服务器，具有可自定义的文档、自动更新和轻松共享.
- [OpenAPI Explorer](https://github.com/Rhosys/openapi-explorer) - 一种根据 OpenAPI 规范生成用户界面的工具，使软件工程师更容易可视化 API 并与之交互.
- [RapiDoc](https://github.com/rapi-doc/RapiDoc) - 一种根据 OpenAPI 规范生成可定制的交互式 API 文档的工具，具有一系列设计选项.
- [Redoc](https://github.com/Redocly/redoc) - 一个开源工具，用于从 OpenAPI (fka Swagger) 定义生成文档，具有可定制的主题、语言支持和品牌.
- [Slate](https://github.com/slatedocs/slate) - A powerful tool that creates static API documentation from markdown, with API reference docs and code samples.
- [Stoplight Elements](https://github.com/stoplightio/elements)  - 由 OpenAPI 和 Markdown 提供支持的精美 API 文档. 使用这些 UI 组件创建 API 参考文档，或更完整的文档以及包含教程、操作指南等的 Markdown 文章.
- [SwaggerHub](https://swagger.io/tools/swaggerhub/) - 为团队构建的集成 API 设计和文档平台，具有版本控制、测试自动化以及与流行的 API 工具的集成.
- [Swagger UI](https://github.com/swagger-api/swagger-ui) - 用于探索 API 并与之交互的直观工具，具有 API 规范可视化、端点探索和内置交互式控制台.

<!--lint disable-->
<!--lint enable-->
### API Gateway
 *API 网关充当客户端应用程序和后端服务之间的中介，支持请求路由、身份验证、速率限制和缓存等关键功能. 它们通过为各种服务提供统一的入口点来简化管理、保护和监控 API 的过程. *
- [Apinto](https://github.com/eolinker/goku) - 基于 Golang 的微服务网关，提供动态路由、服务编排、多租户管理和 API 访问控制.
- [Ambassador Edge Stack](https://www.getambassador.io/products/edge-stack/api-gateway/) - 一个 Kubernetes 原生 API 网关，通过其可定制的路由、身份验证和速率限制功能帮助大规模管理 API.
- [Apache APISIX](https://github.com/apache/apisix) - 一个动态、实时和高性能的 API 网关，它利用 Apache 插件来增强功能.
- [Gloo Edge](https://www.solo.io/products/gloo-edge/) - 基于 Envoy 代理的 API 网关，为现代微服务架构提供高级流量管理、安全性和可观察性功能.
- [Kong API Gateway](https://github.com/Kong/kong) - 云原生、平台不可知且可扩展的 API 网关，支持插件以便与第三方服务轻松集成.
- [KrakenD API Gateway](https://github.com/devopsfaith/krakend-ce) - 超高性能 API 网关，利用中间件进行快速高效的 API 管理.
- [Ocelot](https://github.com/ThreeMammals/Ocelot) - 一个 .NET API 网关，通过其直观的路由和中间件配置提供了一种简单而优雅的 API 管理方式.
- [Spring Cloud Gateway](https://github.com/spring-cloud/spring-cloud-gateway) - 构建在 Spring 生态系统之上的 API 网关，为 Spring 应用程序提供高级路由和过滤功能.
- [Traefik](https://github.com/traefik/traefik)  - 一个现代的开源 API 网关，旨在处理动态容器环境，例如 Kubernetes、Docker Swarm 和 Mesos. 它提供负载均衡、SSL/TLS 终止、速率限制、熔断等功能.
- [Tyk API Gateway](https://github.com/TykTechnologies/tyk)  - 支持 REST、GraphQL、TCP 和 gRPC 协议的开源企业 API 网关. 它提供高级 API 管理功能，例如速率限制、访问控制和分析.

<!--lint disable-->
<!--lint enable-->
### API Testing
 *API 测试工具部分提供了一系列软件工具和框架，开发人员可以使用这些工具和框架来测试 REST API 和消息代理. 本节包括用于测试 REST API 和消息代理的 GUI 客户端、用于模拟 API 响应的模拟工具，以及用于自动化测试过程的各种测试工具和框架. *
- API客户端
  - [Advanced REST Client](https://github.com/advanced-rest-client/arc-electron) - 专为测试和调试 RESTful Web 服务而设计的开源 API 工具.
  - [curl](https://github.com/curl/curl) - 用于通过各种协议使用 URL 传输数据的命令行工具.
  - [curlie](https://github.com/rs/curlie) - 前端可通过 httpie 的易用性进行卷曲，而不会影响性能和功能.
  - [HTTPie](https://github.com/httpie/httpie) - 用户友好的命令行 HTTP 客户端，可简化 HTTP 请求/响应检查和操作.
  - [Insomnia](https://github.com/Kong/insomnia) - 旨在简化 API 测试和调试的跨平台 HTTP 和 GraphQL 客户端.
  - [Postman](https://www.postman.com/product/api-client/) - 用于简化 API 开发和测试过程的综合工具，具有发出 HTTP 请求、生成模拟服务器和创建 API 文档等功能.
  - [resty](https://github.com/micha/resty) - 用于构建 HTTP 客户端的 Lua 框架，提供用于与 REST 服务交互的 shell 接口.
  - [SoapUI](https://www.soapui.org/tools/soapui) - 专为测试 SOAP 和 REST Web 服务而设计的开源 Web 服务测试应用程序.
- MQ客户端
  - [JMSToolBox](https://github.com/jmstoolbox/jmstoolbox) - 通用 JMS 客户端，旨在与各种基于 JMS 的消息代理进行交互.
  - [kcat](https://github.com/edenhill/kcat) - Apache Kafka 的通用非 JVM 生产者和消费者，充当 Kafka 的 netcat.
  - [MQTT Explorer](https://github.com/thomasnordquist/MQTT-Explorer) - 具有结构化主题概述的全方位 MQTT 客户端，适用于调试和测试基于 MQTT 的系统.
  - [Offset Explorer](https://www.kafkatool.com) - 用于管理和使用 Apache Kafka 集群的 GUI 应用程序，以前称为 Kafka 工具.
  - [Service Bus Explorer](https://github.com/paolosalvatori/ServiceBusExplorer) - Azure 服务总线的 GUI 应用程序，提供高级功能，如导入/导出功能以及测试主题、队列、订阅、中继服务、通知中心和事件中心的能力.
- 模拟工具
  - [Microcks](https://github.com/microcks/microcks) - 用于 API 模拟和测试的开源 Kubernetes 原生工具，支持 AsyncAPI、OpenAPI、Postman Collections 等.
  - [Mockable](https://www.mockable.io/) - 模拟 RESTful API 或 SOAP 网络服务的简单可配置服务.
  - [Mockoon](https://mockoon.com/) - 用于设计和运行模拟 REST API 的易于使用的工具.
  - [MockServer](https://github.com/mock-server/mockserver) - 轻松模拟您通过 HTTP 或 HTTPS 集成的任何系统.
  - [Mocky](https://designer.mocky.io/) - 用于生成自定义 HTTP 响应的免费且无限制的在线服务.
  - [Prism](https://github.com/stoplightio/prism) - 开源 HTTP 模拟服务器，可以模仿您的 API 行为，就好像您已经构建了它一样.
  - [WireMock](https://github.com/tomakehurst/wiremock) - 模拟您的 API 以进行快速、稳健和全面的测试.
- 测试工具和框架
  - [Apache JMeter](https://github.com/apache/jmeter) - Open-source Java-based load testing tool that can be used to test the performance and scalability of web applications, databases, and other network services.
  - [Gatling](https://github.com/gatling/gatling) - 一种开源负载测试工具，允许用户以代码形式编写和运行负载测试，提供详细的性能报告以优化系统性能.
  - [Karate](https://github.com/intuit/karate) - 将 API 测试自动化、模拟、性能测试甚至 UI 自动化组合到一个统一框架中的开源工具.
  - [Pyresttest](https://github.com/svanoort/pyresttest) - 用于轻松测试 REST 服务的 Java DSL.
  - [REST Assured](https://github.com/rest-assured/rest-assured) - 用于轻松测试 REST 服务的 Java DSL.
  - [Schemathesis](https://github.com/schemathesis/schemathesis) - 用于 API 模式的基于属性的测试的 Python 库.
  - [Taurus](https://github.com/Blazemeter/taurus) - 一个用于持续测试的开源框架，通过用户友好的界面简化测试执行和管理，并与各种测试工具和框架集成.

<!--lint disable-->
<!--lint enable-->
### BRE
 *业务规则引擎和业务规则管理系统 (BRMS) 是允许组织定义、管理和执行业务规则的软件系统. 这些规则用于自动化决策过程、执行业务策略并确保合规性.  BRMS 为组织提供了一种方式来集中管理其业务规则并快速轻松地对其进行更改，而无需更改底层代码. 对于需要敏捷并快速响应不断变化的市场条件的企业来说，这是一个有价值的工具. *
- [Drools](https://github.com/kiegroup/drools) - 开源工具，支持一致性级别 3 的决策模型和符号 (DMN) 模型，带有用于核心开发的 Eclipse IDE 插件.
- [Easy Rules](https://github.com/j-easy/easy-rules) - 用于直接规则处理的简单 Java 规则引擎.
- [NxBRE](https://github.com/ddossot/NxBRE/wiki) - 专为.NET 平台设计的开源规则引擎.
- [OpenL Tablets](https://github.com/openl-tablets/openl-tablets) - 开源业务规则引擎（BRE、BRMS）和决策管理系统，允许用户定义、管理和执行业务规则和决策表.

<!--lint disable-->
<!--lint enable-->
### BPM
 *BPM 解决方案是帮助企业简化和自动化其运营流程以提高效率和生产力的软件工具. 这些解决方案通常提供流程建模、工作流管理、任务自动化和报告等功能. 它们可用于自动化范围广泛的流程，从数据输入等简单任务到涉及多个部门和利益相关者的复杂工作流程. *
- [Appian BPM Suite](https://appian.com/platform/complete-automation/business-process-management-bpm.html) - 一个将低代码开发与流程管理相结合的平台，允许 IT 和公民开发人员构建以流程为中心和以案例为中心的应用程序.
- [Genpack Cora SeQuence](https://www.genpact.com/cora/sequence) - 一种用于协调业务流程、推动业务敏捷性和提高成本效率的工具.
- [IBM Business Automation Workflow](https://www.ibm.com/products/business-automation-workflow) - 用于开发和管理业务应用程序的综合业务流程管理平台.
- [Oracle BPM Suite](https://www.oracle.com/middleware/technologies/bpm.html) - 用于开发、管理和使用以业务流程为中心的业务应用程序的集成环境.
- [Pega Platform](https://www.pega.com/products/platform) - 具有高级劳动力分析功能的业务流程管理和机器人流程自动化 (RPA) 平台.
- [Red Hat Process Automation Manager](https://www.redhat.com/en/technologies/jboss-middleware/process-automation-manager) - 应用程序开发平台，使开发人员和业务专家能够创建可自动化业务运营的云原生应用程序.
- [SAP Process Orchestration](https://www.sap.com/products/process-orchestration.html) - 业务流程管理产品和应用程序基础架构. 
- [TIBCO BPM Enterprise](https://www.tibco.com/products/business-process-management) - 业务流程管理平台，提供流程自动化、文档、人力资本管理、流程模式和预测性运营分析功能.

<!--lint disable-->
<!--lint enable-->
### Data Mapping Solution
 *数据映射工具用于定义和转换不同系统、应用程序和格式之间的数据. 这些工具允许将数据从源映射到目标，从而允许数据转换和集成. 本节涵盖不同的数据映射解决方案，可用于促进不同用例的数据映射和转换过程.*
- [AltasMap](https://github.com/atlasmap/atlasmap)  - 基于 Web 的数据映射解决方案，可简化 Java、XML、CSV 和 JSON 数据源之间的集成. 其交互式用户界面使配置集成变得容易.
- [Altova MapForce](https://www.altova.com/mapforce)  - 一个图形数据映射工具，可以处理任何到任何转换和集成任务. 它简化了复杂的映射任务，使软件工程师能够更快地完成项目.
- [JOLT](https://github.com/bazaarvoice/jolt)  - 基于 Java 的 JSON 到 JSON 转换库，它使用 JSON 文档作为转换的“规范”.  JOLT 为软件工程师提供了一种简单的方法来转换 JSON 数据.
- [JSLT](https://github.com/schibsted/jslt)  - 受 jq、XPath 和 XQuery 启发的完整的 JSON 查询和转换语言. 借助 JSLT，软件工程师可以快速轻松地转换 JSON 数据以满足他们的需求.

<!--lint disable-->
<!--lint enable-->
### ESB
 *企业服务总线 (ESB) 解决方案通过提供允许它们交换信息的通信层来促进不同系统和应用程序的集成.  ESB 提供了一系列功能，例如消息路由、转换、协议转换和数据中介. 它们通常支持各种消息传递模式和通信协议，并提供用于管理和监控消息流量的集中平台. *
- [Anypoint Platform](https://www.mulesoft.com/platform/enterprise-integration) - A comprehensive API management and integration platform that simplifies connecting applications from Mulesoft.
- [Apache ServiceMix](https://servicemix.apache.org/) - 一个开源集成容器，结合了 Apache ActiveMQ、Camel、CXF 和 Karaf 的功能，提供了一个灵活的解决方案.
- [ArcESB](https://www.arcesb.com/integration/) - 一个多功能的集成平台，跨应用程序无缝同步数据，与合作伙伴集成，并提供数据可访问性.
- [IBM App Connect](https://www.ibm.com/cloud/app-connect) - 一个可以连接应用程序的集成平台，无论它们使用何种消息格式或协议，以前称为 IBM Integration Bus.
- [NServiceBus](https://github.com/Particular/NServiceBus) - 基于 .NET 的服务总线，提供直观的开发人员友好环境.
- [Oracle Service Bus](https://www.oracle.com/middleware/technologies/service-bus.html) - 连接、虚拟化和管理服务与应用程序之间交互的集成平台.
- [Oracle SOA Suite](https://www.oracle.com/middleware/technologies/soasuite.html) - 一个平台，使系统开发人员能够设置和管理服务并将它们编排到复合应用程序和业务流程中.
- [Red Hat Fuse](https://www.redhat.com/en/technologies/jboss-middleware/fuse) - 支持分布式集成能力的云原生集成平台.
- [Software AG webMethods Integration Server](https://www.softwareag.com/en_corporate/platform/integration-apis/webmethods-integration.html) - 一个集成平台，可以更快地集成任何应用程序.
- [TIBCO BusinessWorks](https://www.tibco.com/products/tibco-businessworks) - 为混合集成实施企业模式的平台.
- [UltraESB](https://www.adroitlogic.com/products/ultraesb/) - 支持零拷贝代理的 ESB，可利用直接内存访问和非阻塞 IO 实现极致性能.
- [WSO2 Enterprise Integrator](https://wso2.com/integration/) - 一个以 API 为中心、云原生和分布式集成平台，旨在为软件工程师提供强大的解决方案.

<!--lint disable-->
<!--lint enable-->
### ETL
 *ETL（提取、转换、加载）和 ELT（提取、加载、转换）是用于集成和整合来自多个来源的数据的过程. 本节涵盖了一系列用于执行这些任务的开源和商业工具，包括数据摄取、转换和加载到数据仓库或其他数据存储系统中. *
- [Apache NiFi](https://github.com/apache/nifi) - 一个自动化的数据集成平台，可以在不同的系统之间有效地移动数据.
- [CloverETL](http://www.cloveretl.com/) - 全面的数据集成软件套件，非常适合数据迁移、仓储以及将数据输入 BI 和报告应用程序. 
- [Hevo](https://hevodata.com/) - 一个完全自动化的无代码数据管道平台，支持跨数据库、SaaS 应用程序、云存储、SDK 和流媒体服务的 150 多个集成.
- [IBM DataStage](https://www.ibm.com/products/datastage) - 一个强大的数据集成平台，可帮助企业理解、清理、转换和交付可信信息.
- [Informatica PowerCenter](https://www.informatica.com/products/data-integration/powercenter.html) - 一款值得信赖的企业数据集成和管理软件，支持大数据和云分析.
- [Microsoft SSIS](https://docs.microsoft.com/en-us/sql/integration-services/sql-server-integration-services) - 构建企业级数据集成和转换解决方案的可靠平台.
- [Oracle Data Integrator](https://www.oracle.com/middleware/technologies/data-integrator.html) - 一个全面的数据集成平台，涵盖所有数据集成需求，包括批量加载、集成流程和支持 SOA 的数据服务.
- [Pentaho Data Integration](https://github.com/pentaho/pentaho-kettle) - 一个用户友好的平台，使用户能够使用可视化工具从任何来源摄取、混合、清理和准备各种数据，无需编码和复杂性.
- [SAS Data Management](https://www.sas.com/en_us/software/data-management.html) - 一个强大的平台，可帮助转换、集成、管理和保护数据，同时提高其整体质量和可靠性.
- [Stitch](https://www.stitchdata.com/) - 一种简单但功能强大的 ETL 服务，可集成来自数十个不同来源的数据，非常适合各种规模的企业.
- [Talend Data Integration](https://www.talend.com/products/integrate-data/) - 一个多功能平台，可将来自多个来源的数据汇集在一起​​，为您的所有业务决策提供支持.

<!--lint disable-->
<!--lint enable-->
### Integration Frameworks
 *集成框架部分包括可帮助开发人员在其应用程序中实施和管理集成模式的软件工具和库. 这些框架基于完善的企业集成模式 (EIP)，它为设计和实施集成解决方案提供了标准的词汇表和架构. 本节中的框架可以通过提供预构建的连接器、消息路由和转换功能来帮助简化集成不同系统、应用程序和数据源的过程. *
- [Apache Camel](https://github.com/apache/camel/) - 一个强大的集成框架，使用企业集成模式来连接和统一不同的传输 API.
- [Ballerina](https://github.com/ballerina-platform/ballerina-lang) - 一种开源编程语言，可简化网络服务的创建、使用和组合.
- [Spring Integration](https://github.com/spring-projects/spring-integration) - 支持企业集成模式的 Spring 编程模型的扩展，允许简化各种系统的集成.

<!--lint disable-->
<!--lint enable-->
### iPaaS
 *集成平台即服务 (iPaaS) 是一个基于云的平台，使企业能够轻松集成不同的系统、应用程序和数据源. 它提供了一个统一的平台来管理各种系统之间的数据流，简化了集成不同系统和自动化工作流程的过程.  iPaaS 工具通常提供用于设计、部署和管理集成的可视化界面，以及用于与流行系统和服务集成的预构建连接器和 API. *
- [Anypoint Platform](https://www.mulesoft.com/platform/saas/cloudhub-ipaas-cloud-based-integration) - 一个强大的集成平台，将 API 管理和集成功能结合在一个平台中，使软件工程师能够轻松集成各种应用程序.
- [Boomi AtomSphere](https://boomi.com/platform) - 一个云原生、统一、开放和智能的平台，连接一切和每个人，使软件工程师能够轻松创建和管理集成.
- [Jitterbit Harmony](https://www.jitterbit.com/platform/ipaas)  - 一个全面的集成平台，提供预构建的模板和工作流来自动化业务流程. 它集成了数以千计的应用程序并简化了软件工程师的集成.
- [IBM Cloud Integration](https://www.ibm.com/cloud/integration)  - 下一代集成平台，使用 AI 为软件工程师提供创新的集成方法. 该平台加速了集成过程，使其更快、更具可扩展性.
- [Informatica Intelligent Cloud Services](https://www.informatica.com/products/cloud-integration.html)  - 一套旨在提高生产力并提高速度和规模的云数据管理产品. 软件工程师可以使用该平台高效地管理数据和集成应用程序.
- [OpenText Alloy](https://businessnetwork.opentext.com/enterprise-data-management/)  - 一个强大的企业数据管理平台，使组织能够超越基本集成并将数据转化为洞察力和行动. 软件工程师可以使用这个平台来管理数据和改善业务成果.
- [Oracle Integration Cloud Service](https://www.oracle.com/integration/application-integration/)  - 一个强大的平台，可通过与任何 SaaS 或本地应用程序的预构建连接加快上线时间. 软件工程师可以使用这个平台来简化集成流程和操作.
- [SnapLogic Intelligent Integration Platform](https://www.snaplogic.com/products/intelligent-integration-platform)  - 连接各种应用程序和数据环境的综合集成平台. 软件工程师可以使用该平台快速高效地集成数据和应用程序.
- [Software AG webMethods Hybrid Integration Platform](https://www.softwareag.com/en_corporate/platform/integration-apis/application-integration.html) - An all-in-one integration platform that enables software engineers to integrate all their applications in a single platform. This platform simplifies integration processes and improves efficiency.
- [TIBCO Cloud Integration](https://www.tibco.com/products/cloud-integration)  - 一个灵活的平台，使软件工程师能够通过 API 主导和事件驱动的集成来集成任何东西. 这个平台使每个人都能集成任何东西，使集成过程更快、更高效.
- [Workato](https://www.workato.com/) - 用于整个组织的集成和工作流自动化的单一平台，为软件工程师提供了一个强大的平台来简化集成流程和简化操作.

<!--lint disable-->
<!--lint enable-->
### MaaS
 *云消息传递即服务 (MaaS) 是指基于云的消息传递平台，可在分布式应用程序和服务之间实现可靠、安全和可扩展的通信. 这些平台提供各种消息传递模式，例如发布-订阅、请求-回复和流式传输. 它们还提供消息路由、过滤、转换和持久性等功能，并支持各种协议和 API 以与不同系统集成.*
- [Amazon MQ](https://aws.amazon.com/amazon-mq)  - 支持 Apache ActiveMQ 和 RabbitMQ 的完全托管消息代理服务. 它为您的应用程序提供可靠、安全且可扩展的消息传递基础架构.
- [Amazon MSK](https://aws.amazon.com/msk)  - Apache Kafka 的完全托管服务，可简化 Kafka 集群的设置、扩展和管理. 它为您的数据流需求提供高度可用、持久且高性能的消息传递服务.
- [Amazon SQS](https://aws.amazon.com/sqs)  - 一种完全托管的消息队列服务，使您能够分离和扩展微服务、分布式系统和无服务器应用程序. 它提供可靠、安全且高度可用的消息存储和传递系统.
- [Amazon SNS](https://aws.amazon.com/sns)  - 一种完全托管的发布/订阅消息服务，使您能够在分布式系统、微服务和事件驱动的无服务器应用程序之间发送和接收消息. 它提供了一种灵活、可扩展且经济高效的方式来通知订阅者事件和消息.
- [Alibaba Cloud Message Queue for Apache Kafka](https://www.alibabacloud.com/product/kafka)  - 一项完全托管的 Apache Kafka 服务，可为您的应用程序提供高吞吐量、低延迟和高可用性的消息流. 它提供与其他阿里云服务的轻松集成和无缝数据迁移.
- [Alibaba Cloud Message Queue for RabbitMQ](https://www.alibabacloud.com/product/rabbitmq) - A distributed and fully managed messaging service that provides high scalability, low latency, and high throughput for your applications. It offers flexible deployment options, easy management, and robust security features.
- [Alibaba Cloud Message Service](https://www.alibabacloud.com/product/message-service)  - 分布式消息传递和通知服务，支持应用程序和分离系统之间的并发操作和消息传输. 它为您的消息传递需求提供高可靠性、可扩展性和容错能力.
- [AlibabaMQ for Apache RocketMQ](https://www.alibabacloud.com/product/mq)  - 一种分布式消息队列服务，支持微服务、分布式系统和无服务器应用程序之间基于消息的可靠异步通信. 它为您的消息流需求提供高可用性、可扩展性和持久性.
- [Anypoint MQ](https://www.mulesoft.com/platform/anypoint-mq-message-queue)  - 与 Anypoint 平台完全集成的企业级云消息服务. 它提供灵活可靠的消息传递基础架构，使您能够集成和编排您的应用程序和系统.
- [Azure Service Bus](https://azure.microsoft.com/en-us/services/service-bus/) - 可靠的云消息服务，提供多种消息模式，例如发布/订阅和请求/响应，并支持一系列协议和标准.
- [CloudAMQP](https://www.cloudamqp.com/)  - RabbitMQ 即服务，为您的应用程序提供完全托管和可扩展的消息代理服务. 它提供了一个简单易用的基于 Web 的管理控制台、高级监控和分析，以及与其他云服务的无缝集成.
- [CloudKarafka](https://www.cloudkarafka.com/)  - 一种经济实惠且直接的 Kafka 服务，可在 AWS 和 Google Cloud 上提供完全托管且可扩展的 Kafka 集群. 它提供了一个用户友好的基于 Web 的仪表板、高级安全功能以及与其他云服务的无缝集成.
- [Google Cloud Pub/Sub](https://cloud.google.com/pubsub)  - 支持事件驱动系统和流分析的消息传递和摄取服务. 它为您的应用程序提供高吞吐量、低延迟和可靠的消息传递. 它支持灵活的消息传递模式，如发布/订阅和推/拉，并与其他谷歌云服务无缝集成.
- [Huawei Cloud Distributed Message Service](https://www.huaweicloud.com/intl/en-us/product/dms.html)  - 一种完全托管的高性能消息队列服务，可在分布式应用程序之间实现可靠、灵活和异步的通信. 它提供高可扩展性、安全性和持久性，并支持各种消息传递模式和协议.
- [Huawei Cloud Distributed Message Service for Kafka](https://www.huaweicloud.com/intl/en-us/product/dmskafka.html)  - 一种托管的 Apache Kafka 服务，可轻松设置、扩展和管理 Kafka 集群. 它提供高可用性、性能和安全性，并与其他华为云服务无缝集成.
- [IBM MQ on Cloud](https://www.ibm.com/cloud/mq) - 基于云的消息传递服务，可轻松实现跨企业应用程序、系统和服务的无缝数据传输.
- [IronMQ](https://www.iron.io/mq) - 专门为云构建的弹性消息队列，允许可靠和可扩展的消息处理.
- [Oracle Cloud Streaming](https://www.oracle.com/cloud/cloud-native/streaming/) - 具有 Apache Kafka 兼容性的无服务器实时事件流平台，可提供高性能且经济高效的数据处理.
- [Solace PubSub+ Cloud](https://solace.com/products/platform/cloud/) - 一个一体化的事件流、管理和洞察平台，提供对数据管道的完整可见性和控制.
- [Yandex Message Queue](https://cloud.yandex.com/en/services/message-queue) - 与 Amazon SQS HTTP API 兼容的云消息服务，可轻松与现有系统和服务集成.
- [Yandex Managed Service for Apache Kafka](https://cloud.yandex.com/en/services/managed-kafka) - 一个完全托管的 Apache Kafka 服务，具有自动扩展、监控和维护功能，提供无障碍的数据流.

<!--lint disable-->
<!--lint enable-->
### Managed File Transfer
 *托管文件传输 (MFT) 解决方案提供安全可靠的文件传输功能，可帮助组织满足法规遵从性要求、提高运营效率并降低数据泄露风险.  MFT 软件通常包括加密、数字签名、用户访问控制和详细审计日志等功能，以确保数据安全传输并可在整个传输过程中进行跟踪.*
- [ArcESB Managed File Transfer](https://www.arcesb.com/mft/)  - 为寻求简化文件传输流程的企业提供的全面解决方案. 其用户友好的界面和强大的功能提供了一个可以有效处理文件传输的一体化 MFT 解决方案.
- [Axway Managed File Transfer](https://www.axway.com/en/products/managed-file-transfer) - 此 MFT 解决方案旨在简化企业的文件传输服务，提供高级功能和安全措施以确保安全可靠的数据传输.
- [Cornerstone MFT](https://southrivertech.com/products/cornerstone/) - 具有高可用性和故障转移功能的企业级 MFT 服务器解决方案，提供了一种自动化和管理大规模文件传输的有效方式.
- [IBM Sterling Secure File Transfer](https://www.ibm.com/products/secure-file-transfer)  - 一个快速且可扩展的文件传输平台，提供高级安全功能和灵活的架构. 它非常适合需要可靠且安全的 MFT 平台的企业.
- [Oracle Managed File Transfer](https://www.oracle.com/middleware/technologies/mft/managed-file-transfer.html) - 全面的 MFT 解决方案，可实现安全的文件交换和管理，为企业轻松传输数据提供可靠、高效的方式.
- [TIBCO Managed File Transfer](https://www.tibco.com/products/tibco-managed-file-transfer)  - 一个集中管理的 MFT 平台，具有强大的自动化功能和高级安全功能，能够支持所有文件传输用例. 对于需要全面的 MFT 解决方案的企业来说，这是一个理想的选择.

<!--lint disable-->
<!--lint enable-->
### Master Data Management
 *主数据管理解决方案可帮助组织创建跨不同系统、应用程序和部门的准确且一致的数据的单一权威来源. 这些工具提供数据剖析、清理、丰富和治理功能，使组织能够提高数据质量、减少错误并提高运营效率. *
- [IBM InfoSphere Master Data Management](https://www.ibm.com/products/ibm-infosphere-master-data-management) - 用于管理主数据的综合解决方案，可在整个组织中提供单一事实来源.
- [Informatica Multidomain MDM](https://www.informatica.com/products/master-data-management/multidomain-mdm.html) - 一种一体化解决方案，使您能够在一个地方管理和治理所有主数据域.
- [Oracle Enterprise Data Management](https://www.oracle.com/performance-management/enterprise-data-management/) - 通过集中和管理您的主数据，帮助您更快、更有效地适应和响应变化.
- [SAP Master Data Governance](https://www.sap.com/products/master-data-governance.html) - 通过整合和集中管理您的主数据生命周期，简化并提高数据的质量和一致性.
- [SAS MDM](https://support.sas.com/en/software/mdm-support.html) - 提供公司数据的统一视图，将各种来源的信息整合到一个主记录中，以提高准确性和一致性.
- [Software AG OneData for MDM](https://www.softwareag.com/resources/Master-data-management) - 确保只有可靠、准确和经过批准的信息流经您的系统、流程和应用程序，提供“一个版本的真相”.
- [Teradata MDM](https://www.teradata.co.uk/Products/Applications/Master-Data-Management) - 通过使用一致的参考数据建立准确的分析数据基础，推动显着的投资回报率.
- [TIBCO EBX](https://www.tibco.com/products/tibco-ebx-software) - 一个管理、管理和使用所有共享数据资产的单一解决方案，确保整个组织的一致性和准确性.

<!--lint disable-->
<!--lint enable-->
### Messaging
 *消息代理是一种中间件，它通过促进消息交换来允许不同应用程序或系统之间的通信. 它们可以处理不同的消息传递模式，例如点对点、发布-订阅和请求-回复，并提供消息转换、路由和过滤等功能.*
- [Apache ActiveMQ](https://github.com/apache/activemq)  - 实现 Java 消息服务 (JMS) 并允许同步到异步通信转换的开源消息代理. 提供可靠的消息传递并支持多种协议和消息传递样式.
- [Apache Kafka](https://github.com/apache/kafka)  - 为高吞吐量和容错设计的分布式消息系统. 以其分布式架构和高效的数据存储支持实时数据处理和流处理应用程序.
- [Apache Pulsar](https://github.com/apache/pulsar)  - 支持传统消息传递和流媒体用例的分布式发布/子消息传递系统. 提供可扩展且灵活的架构，并支持多种消息传递协议.
- [Apache RocketMQ](https://github.com/apache/rocketmq)  - 一个快速可靠的分布式消息传递平台，专为高容量和低延迟消息传递场景而设计. 提供高效的消息存储和检索，并支持各种消息传递模式.
- [Apache Qpid](https://qpid.apache.org)  - 支持高级消息队列协议 (AMQP) 和多种编程语言和平台的消息传递工具. 通过可靠、高效的消息传递提供企业级消息传递功能.
- [Eclipse Mosquitto](https://github.com/eclipse/mosquitto)  - 实现 MQTT 协议的轻量级开源消息代理. 专为低功耗设备设计，支持消息加密和认证.
- [IBM MQ](https://www.ibm.com/products/mq)  - 强大的企业级消息传递系统，可在应用程序之间实现安全高效的通信. 提供高可用性和灾难恢复功能，并支持多种消息传递协议.
- [KubeMQ](https://kubemq.io/)  - 基于 Kubernetes 的消息代理和队列系统，专为可扩展性、高可用性和安全性而设计. 提供与 Kubernetes 的无缝集成并支持各种消息传递模式.
- [NATS](https://github.com/nats-io/gnatsd)  - 专为微服务、物联网和云原生系统设计的轻量级高性能消息传递系统. 提供高效可靠的消息传递并支持多种消息传递协议.
- [Oracle AQ](https://www.oracle.com/database/technologies/advanced-queuing.html)  - 一种消息系统，提供企业消息功能，在 Oracle 数据库中被广泛使用. 提供可靠且高效的消息传递并支持多种消息传递样式.
- [RabbitMQ](https://github.com/rabbitmq/rabbitmq-server)  - 一个实现 AMQP 并支持多种消息协议和模式的开源消息代理. 提供可靠和高效的消息传递，并支持集群和高可用性.
- [Redpanda](https://github.com/vectorizedio/redpanda)  - 与 Kafka 兼容且不需要 Zookeeper 或 JVM 的流媒体平台. 提供高性能和低延迟的消息传递，并支持流处理和分析.
- [Red Hat AMQ](https://www.redhat.com/en/technologies/jboss-middleware/amq)  - 基于 Apache ActiveMQ 和 Apache Kafka 等开源社区的消息传递系统. 通过可靠、高效的消息传递提供企业级消息传递功能.
- [TIBCO Enterprise Message Service](https://www.tibco.com/products/tibco-enterprise-message-service)  - 基于标准的 JMS 实现，允许在应用程序之间轻松交换消息. 提供可靠且高效的消息传递并支持各种消息传递协议和模式.
- [VerneMQ](https://github.com/vernemq/vernemq)  - 专为可扩展性和可靠性而设计的高性能分布式 MQTT 消息代理. 提供高效可靠的消息传递并支持多种消息传递协议和模式.

<!--lint disable-->
<!--lint enable-->
### RPA
 *机器人流程自动化 (RPA) 解决方案是一种软件工具，可在业务流程中自动执行重复的、基于规则的任务.  RPA 机器人可以准确、快速地执行数据输入、数据提取和数据处理等任务，从而让人类员工腾出时间专注于更复杂的任务.*
- [Automation Anywhere](https://www.automationanywhere.com/)  - 提供机器人过程自动化 (RPA) 解决方案的智能自动化生态系统. 该解决方案旨在自动化业务流程并提高运营效率，同时减少错误和成本.
- [Blue Prism](https://www.blueprism.com/products/intelligent-rpa-automation/)  - 为企业提供智能自动化功能的无代码自动化 RPA 平台. 该平台旨在通过自动化重复性数字任务来降低运营成本并提高生产力.
- [UiPath](https://www.uipath.com/product)  - 一个提供 RPA 解决方案的平台，用于自动执行通常由人执行的重复性数字任务. 该解决方案提供了一个全面的自动化平台，使企业能够实现流程自动化并提高效率.
- [WorkFusion](https://www.workfusion.com/platform/)  - 为提供 RPA 解决方案的企业提供的自动化平台. 该平台旨在自动化手动任务、减少错误并提高效率. 它提供了一套全面的工具，用于自动化工作流程和简化操作.

<!--lint disable-->
<!--lint enable-->
### Self-Service Integration
 *自助服务和公民集成器工具旨在使非技术用户无需广泛的编程知识即可构建集成. 这些工具通常具有用于流行应用程序和服务的拖放式界面和预建连接器. *

- [IFTTT](https://ifttt.com/) - 一个强大的自助服务和公民集成工具，使用户能够通过使用条件语句连接多个 Web 服务来创建自定义工作流程，从而轻松提高生产力.
- [Microsoft Power Automate](https://powerautomate.microsoft.com) - 这种基于云的服务提供了一个用户友好的界面，可以无缝地创建自动化工作流程，轻松集成不同的应用程序和服务，简化复杂的任务.
- [Oracle Self-Service Integration](https://docs.oracle.com/en/cloud/paas/self-service-integration-cloud/index.html) - 使用 Oracle 的自助服务集成工具轻松地在各种云应用程序之间自动执行任务，提供无缝且高效的集成过程.
- [Zapier](https://zapier.com/) - 一种直观的自动化工具，可连接数百个 Web 服务，轻松创建流程之间的自动化，简化任务并提高整体生产力.

<!--lint disable-->
<!--lint enable-->
### Workflow engine
 *支持复杂工作流或业务流程的设计、执行和监控的软件工具. 工作流引擎提供了一种自动化和简化业务流程的方法，而编排引擎有助于管理不同系统或服务之间的交互. *
- [Activiti](https://github.com/Activiti/Activiti) - 用于执行 BPMN（业务流程模型和表示法）工作流的轻量级和以 Java 为中心的开源引擎.
- [Apache Airflow](https://github.com/apache/airflow) - 一个平台，允许您以编程方式创建、安排和监控工作流，从而更轻松地管理和自动化复杂的数据管道.
- [Argo Workflows](https://github.com/argoproj/argo-workflows) - 一个开源的容器原生工作流引擎，旨在在 Kubernetes 上编排并行作业，从而更轻松地在云原生环境中管理和自动化复杂的工作流.
- [Azkaban](https://github.com/azkaban/azkaban) - 一个分布式工作流管理器，帮助解决Hadoop作业依赖问题，使得在大规模数据处理环境中更容易调度和管理工作流.
- [Bonita](https://github.com/bonitasoft/bonita-engine) - 带有设计器和可选开发环境的开源 BPMN 引擎，可以更轻松地构建和自动化复杂的业务流程.
- [Cadence](https://github.com/uber/cadence) - 一个容错的、有状态的代码平台，可以更轻松地构建和管理复杂的、长时间运行的应用程序.
- [Camunda](https://github.com/camunda/camunda-bpm-platform) - 一个开源工作流和决策自动化平台，可帮助您以灵活且可扩展的方式自动化业务流程和决策.
- [Conductor](https://github.com/Netflix/conductor) - 基于云的编排引擎，旨在在微服务架构中运行和管理工作流.
- [Elsa Core](https://github.com/elsa-workflows/elsa-core) - 一个库，可以在任何 .NET Core 应用程序中执行工作流，从而更容易在 .NET 环境中自动化业务流程.
- [Flowable](https://github.com/flowable/flowable-engine) - 一组紧凑高效的开源业务流程引擎，可以更轻松地以可扩展且可靠的方式实现业务流程自动化.
- [jBPM](https://github.com/kiegroup/jbpm) - 用于构建业务应用程序的工具包，可帮助您自动化业务流程和决策，从而更轻松地管理复杂的工作流程.
- [StackStorm](https://github.com/StackStorm/st2) - 一个强大的自动化引擎，提供传感器、触发器、规则、工作流和操作，以帮助您自动化和编排复杂的工作流和应用程序.

<!--lint disable-->
<!--lint enable-->
## Integration Patterns
 *集成模式为企业内的常见集成问题提供标准化解决方案. 企业集成模式 (EIP) 提供了一种描述集成问题和解决方案的通用语言，而集成架构模式解决了企业架构师的高级问题. 面向服务的架构 (SOA) 模式为设计和实施面向服务的架构提供指导，确保服务可扩展、可重用和松散耦合. *
### Enterprise Integration Patterns
*模式来自 Gregor Hohpe 和 Bobby Woolf 的一本书.*
- [Aggregator](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Aggregator.html) - 我们如何组合单个但相关消息的结果，以便将它们作为一个整体进行处理？  
- [Canonical Data Model](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CanonicalDataModel.html) - 在集成使用不同数据格式的应用程序时如何最大程度地减少依赖性？
- [Channel Adapter](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ChannelAdapter.html) - 如何将应用程序连接到消息系统，以便它可以发送和接收消息？
- [Channel Purger](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ChannelPurger.html) - 如何防止通道上的“遗留”消息干扰测试或运行系统？
- [Claim Check](https://www.enterpriseintegrationpatterns.com/patterns/messaging/StoreInLibrary.html) - 我们如何在不牺牲信息内容的情况下减少通过系统发送的消息的数据量？  
- [Command Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CommandMessage.html) - 如何使用消息传递来调用另一个应用程序中的过程？  
- [Competing Consumers](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CompetingConsumers.html) - 消息传递客户端如何同时处理多条消息？
- [Composed Message Processor](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DistributionAggregate.html) - 在处理由多个元素组成的消息时，如何维护整个消息流，每个元素可能需要不同的处理？  
- [Content Enricher](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html) - 如果消息发起者没有可用的所有必需数据项，我们如何与另一个系统通信？  
- [Content Filter](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentFilter.html) - 当您只对少数数据项感兴趣时，您如何简化对大消息的处理？  
- [Content-Based Router](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentBasedRouter.html) - 我们如何处理单个逻辑功能（例如，库存检查）的实施分布在多个物理系统中的情况？  
- [Control Bus](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ControlBus.html) - 我们如何有效地管理分布在多个平台和广泛地理区域的消息传递系统？  
- [Correlation Identifier](https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html) - 收到回复的请求者如何知道这是针对哪个请求的回复？
- [Datatype Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DatatypeChannel.html) - 应用程序如何发送数据项以便接收方知道如何处理它？
- [Dead Letter Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DeadLetterChannel.html) - 消息系统将如何处理它无法传递的消息？  
- [Detour](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Detour.html) - 如何通过中间步骤路由消息以执行验证、测试或调试功能？
- [Document Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DocumentMessage.html) - 如何使用消息传递在应用程序之间传输数据？
- [Durable Subscriber](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DurableSubscription.html) - 订户如何在不收听消息时避免丢失消息？
- [Dynamic Router](https://www.enterpriseintegrationpatterns.com/patterns/messaging/DynamicRouter.html) - 如何在保持其效率的同时避免路由器对所有可能目的地的依赖？
- [Envelope Wrapper](https://www.enterpriseintegrationpatterns.com/patterns/messaging/EnvelopeWrapper.html) - 现有系统如何参与对消息格式提出特定要求（例如消息头字段或加密）的消息交换？  
- [Event Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/EventMessage.html) - 如何使用消息传递将事件从一个应用程序传输到另一个应用程序？
- [Event-Driven Consumer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/EventDrivenConsumer.html) - 应用程序如何在消息可用时自动使用它们？
- [Format Indicator](https://www.enterpriseintegrationpatterns.com/patterns/messaging/FormatIndicator.html) - 如何设计消息的数据格式以允许将来可能发生的变化？
- [Guaranteed Delivery](https://www.enterpriseintegrationpatterns.com/patterns/messaging/GuaranteedMessaging.html) - 即使消息传递系统出现故障，发件人如何确保消息能够送达？
- [Idempotent Receiver](https://www.enterpriseintegrationpatterns.com/patterns/messaging/IdempotentReceiver.html) - 消息接收者如何处理重复消息？
- [Invalid Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/InvalidMessageChannel.html) - 消息接收者如何优雅地处理接收到的毫无意义的消息？
- [Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html) - 通过消息通道连接的两个应用程序如何交换一条信息？
- [Message Dispatcher](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageDispatcher.html) - 单个通道上的多个消费者如何协调他们的消息处理？
- [Message Expiration](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageExpiration.html) - 发件人如何指示消息何时应被视为过时且因此不应处理？
- [Message Translator](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageTranslator.html) - 使用不同数据格式的系统如何使用消息传递相互通信？  
- [Message Broker](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBroker.html) - 如何将消息的目的地与发送者分离并保持对消息流的集中控制？
- [Message Bus](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html) - 什么是使独立的应用程序能够一起工作的体系结构，但以解耦的方式使应用程序可以轻松添加或删除而不影响其他应用程序？  
- [Message Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageChannel.html) - 一个应用程序如何使用消息传递与另一个应用程序通信？
- [Message Endpoint](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageEndpoint.html) - 应用程序如何连接到消息通道以发送和接收消息？
- [Message Filter](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Filter.html) - 组件如何避免接收无趣的消息？
- [Message History](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html) - 我们如何有效地分析和调试松散耦合系统中的消息流？  
- [Message Router](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageRouter.html) - 如何解耦各个处理步骤，以便根据一组条件将消息传递到不同的过滤器？
- [Message Sequence](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageSequence.html) - 消息传递如何传输任意大量的数据？
- [Message Store](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageStore.html) - 我们如何在不影响消息系统松散耦合和瞬态特性的情况下报告消息信息？  
- [Messaging Bridge](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingBridge.html) - 如何连接多个消息系统，以便在一个系统上可用的消息在其他系统上也可用？
- [Messaging Gateway](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingGateway.html) - 如何封装从应用程序的其余部分访问消息系统？
- [Messaging Mapper](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingMapper.html) - 如何在域对象和消息传递基础结构之间移动数据，同时保持两者相互独立？
- [Normalizer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Normalizer.html) - 如何处理语义相同但格式不同的消息？
- [Pipes and Filters](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PipesAndFilters.html) - 如何在保持独立性和灵活性的同时对消息进行复杂的处理？  
- [Point-to-Point Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PointToPointChannel.html) - 呼叫者如何确定只有一个接收者会收到文件或执行呼叫？
- [Polling Consumer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PollingConsumer.html) - 当应用程序就绪时，应用程序如何使用消息？  
- [Process Manager](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html) - 当所需步骤在设计时可能未知且可能不是连续的时，我们如何通过多个处理步骤路由消息？
- [Publish-Subscribe Channel](https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html) - 发送方如何向所有感兴趣的接收方广播一个事件？
- [Recipient List](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RecipientList.html) - 我们如何将消息路由到动态指定的收件人列表？
- [Request-Reply](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html) - 当应用程序发送消息时，它如何从接收者那里得到响应？
- [Resequencer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Resequencer.html) - 我们如何才能将相关但无序的消息流恢复为正确的顺序？
- [Return Address](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html) - 回复者如何知道将回复发送到哪里？
- [Routing Slip](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RoutingTable.html) - 当步骤顺序在设计时未知且每条消息可能不同时，我们如何通过一系列处理步骤连续路由消息？  
- [Scatter-Gather](https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html) - 当一条消息需要发送给多个收件人并且每个收件人都可以发送回复时，您如何维护整体消息流？  
- [Selective Consumer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageSelector.html) - 消息消费者如何选择它希望接收的消息？  
- [Service Activator](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingAdapter.html) - 应用程序如何设计既可通过各种消息传递技术又可通过非消息传递技术调用的服务？
- [Smart Proxy](https://www.enterpriseintegrationpatterns.com/patterns/messaging/SmartProxy.html) - 您如何跟踪将回复消息发布到请求者指定的返回地址的服务上的消息？
- [Splitter](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html) - 如果消息包含多个元素，我们如何处理消息，每个元素可能必须以不同的方式处理？  
- [Test Message](https://www.enterpriseintegrationpatterns.com/patterns/messaging/TestMessage.html) - 但是，如果组件正在积极处理消息，但由于内部故障而使传出的消息出现乱码，会发生什么情况？  
- [Transactional Client](https://www.enterpriseintegrationpatterns.com/patterns/messaging/TransactionalClient.html) - 客户端如何控制其与消息系统的交易？  
- [Wire Tap](https://www.enterpriseintegrationpatterns.com/patterns/messaging/WireTap.html) - 您如何检查在点对点通道上传输的消息？  

<!--lint disable-->
<!--lint enable-->
### Integration Architecture Patterns
*用于以高效无缝方式连接系统和应用程序的设计模式.*
- [API-led Connectivity pattern](https://github.com/chanakaudaya/solution-architecture-patterns/blob/master/vendor-neutral/API-led-Connectivity-Pattern.md) - 使用 API 连接不同的系统和应用程序.
- [Anti Corruption Layer Pattern](https://github.com/chanakaudaya/solution-architecture-patterns/blob/master/vendor-neutral/Anti-Corruption-Layer-Pattern.md) - 添加一个层以在系统之间隔离和转换数据.
- [Change Data Capture Pattern](https://github.com/chanakaudaya/solution-architecture-patterns/blob/master/vendor-neutral/Introduction-to-Change-Data-Capture.md) - 实时捕获和传播对数据库或数据源所做的更改.
- [Hybrid API Management pattern](https://github.com/chanakaudaya/solution-architecture-patterns/blob/master/vendor-neutral/Hybrid-API-Management-Pattern.md) - 使用中央控制平面管理跨越云和本地环境的 API.
- [Hybrid Integration pattern](https://github.com/chanakaudaya/solution-architecture-patterns/blob/master/vendor-neutral/Hybrid-Integration-Pattern.md) - 使用集成技术的组合来集成部署在本地和云中的系统和应用程序.

<!--lint disable-->
<!--lint enable-->
### Microservice API Patterns
*MAP (Microservice API Patterns) is a set of proven solutions to common problems encountered when designing, implementing, and maintaining message-based APIs. It focuses on the message representations or payloads exchanged during API calls and their impact on the design and runtime qualities of an API. Proper governance of API specifications and implementations is essential for their long-term maintenance.*
- 基础
    - [Frontend Integration](https://microservice-api-patterns.org/patterns/foundation/FrontendIntegration)  - 与服务器端业务逻辑和数据存储物理分离的客户端终端用户界面如何填充和更新计算结果、数据源搜索的结果集以及有关数据实体的详细信息？ 应用程序前端如何调用后端中的活动或向其上传数据？
    - [Backend Integration](https://microservice-api-patterns.org/patterns/foundation/BackendIntegration) - 独立构建并单独部署的分布式应用程序及其部分如何交换数据并触发相互活动，同时保持系统内部概念完整性而不引入不需要的耦合？
    - [Public API](https://microservice-api-patterns.org/patterns/foundation/PublicAPI) - 如何将 API 提供给组织外部分布在全球、国家和/或区域的无限和/或未知数量的 API 客户端？
    - [Community API](https://microservice-api-patterns.org/patterns/foundation/CommunityAPI) - 如何将 API 的可见性和访问限制为封闭的用户组，该用户组不为单个组织单位工作，而是为多个法律实体（例如公司、非营利/非政府组织和政府）工作？
    - [Solution-Internal API](https://microservice-api-patterns.org/patterns/foundation/SolutionInternalAPI) - 如何将 API 的访问和使用限制在一个应用程序中，例如，同一或另一个逻辑层和/或物理层中的组件？
    - [API Description](https://microservice-api-patterns.org/patterns/foundation/APIDescription)  - 哪些知识应该在 API 提供者和它的客户之间共享？ 应该如何记录这些知识？

- 责任
    - 端点角色
        - [Processing Resource](https://microservice-api-patterns.org/patterns/responsibility/endpointRoles/ProcessingResource) - API 提供者如何允许其客户触发其中的操作？
        - [Information Holder Resource](https://microservice-api-patterns.org/patterns/responsibility/endpointRoles/InformationHolderResource)  - 如何在 API 中公开域数据，但其实现仍然隐藏？  API 如何公开数据实体，以便 API 客户端可以在不影响数据完整性和质量的情况下并发访问和/或修改这些实体？
    - 运营职责
        - [State Creation Operation](https://microservice-api-patterns.org/patterns/responsibility/operationResponsibilities/StateCreationOperation) - API 提供者如何允许其客户报告发生了提供者需要知道的事情，例如，触发即时或稍后处理？
        - [Retrieval Operation](https://microservice-api-patterns.org/patterns/responsibility/operationResponsibilities/RetrievalOperation) - 如何检索远程方（即 API 提供者）可用的信息以满足最终用户的信息需求或允许进一步的客户端处理？
        - [State Transition Operation](https://microservice-api-patterns.org/patterns/responsibility/operationResponsibilities/StateTransitionOperation)  - 客户端如何启动导致提供者端应用程序状态更改的处理操作？  API 客户端和 API 提供者如何分担执行和控制业务流程及其活动所需的责任？
        - [Computation Function](https://microservice-api-patterns.org/patterns/responsibility/operationResponsibilities/ComputationFunction) - 客户端如何在提供者端调用无副作用的远程处理以根据其输入计算出结果？
    - 信息持有者类型
        - [Operational Data Holder](https://microservice-api-patterns.org/patterns/responsibility/informationHolderEndpointTypes/OperationalDataHolder) - API 如何支持想要创建、读取、更新和/或删除表示操作数据的域实体实例的客户端：数据是相当短暂的，在日常业务操作中经常更改，并且有许多传出关系？
        - [Master Data Holder](https://microservice-api-patterns.org/patterns/responsibility/informationHolderEndpointTypes/MasterDataHolder) - 我如何设计一个 API 来提供对长期存在、不经常更改并且会被许多客户端引用的主数据的访问？
        - [Reference Data Holder](https://microservice-api-patterns.org/patterns/responsibility/informationHolderEndpointTypes/ReferenceDataHolder)  - 应如何在 API 端点中处理在许多地方引用、长期存在且对客户端不可变的数据？ 如何在处理资源或信息持有者资源的请求和响应中使用此类参考数据？
        - [Link Lookup Resource](https://microservice-api-patterns.org/patterns/responsibility/informationHolderEndpointTypes/LinkLookupResource) - 消息表示如何在不将消息接收者绑定到这些端点的实际地址的情况下引用其他可能很多且经常更改的 API 端点和操作？
        - [Data Transfer Resource](https://microservice-api-patterns.org/patterns/responsibility/informationHolderEndpointTypes/DataTransferResource) - 两个或多个通信参与者如何在彼此不认识、不能同时可用的情况下交换数据，即使数据在其接收者已知之前已经发送？
- 结构
    - 表示元素
        - [Atomic Parameter](https://microservice-api-patterns.org/patterns/structure/representationElements/AtomicParameter) - 如何在 API 客户端和 API 提供者之间交换简单的非结构化数据（例如数字、字符串、布尔值或二进制数据块）？
        - [Atomic Parameter List](https://microservice-api-patterns.org/patterns/structure/representationElements/AtomicParameterList) - 如何将多个相关的原子参数组合在一个表示元素中，以便它们中的每一个都保持简单，但它们的相关性在 API 描述和运行时消息交换中变得明确？
        - [Parameter Tree](https://microservice-api-patterns.org/patterns/structure/representationElements/ParameterTree) - 在定义复杂表示元素并在运行时交换此类相关元素时，如何表达包含关系？
        - [Parameter Forest](https://microservice-api-patterns.org/patterns/structure/representationElements/ParameterForest) - 如何将多个参数树公开为 API 操作的请求或响应负载？
    - 元素刻板印象
        - [Data Element](https://microservice-api-patterns.org/patterns/structure/elementStereotypes/DataElement)  - 如何在不暴露 API 中提供者内部数据定义的情况下，在 API 客户端和 API 提供者之间交换域/应用程序级信息？  API 客户端和 API 提供者如何从数据管理的角度解耦？
        - [Metadata Element](https://microservice-api-patterns.org/patterns/structure/elementStereotypes/MetadataElement) - 如何用附加信息丰富消息，以便接收者可以正确解释消息内容，而不必对数据语义的假设进行硬编码？
        - [Id Element](https://microservice-api-patterns.org/patterns/structure/elementStereotypes/IdElement)  - 如何在设计时和运行时区分 API 元素？ 在应用领域驱动设计时，如何识别发布语言的元素？
        - [Link Element](https://microservice-api-patterns.org/patterns/structure/elementStereotypes/LinkElement) - 如何在请求和响应消息有效负载中引用 API 端点和操作，以便可以远程调用它们？
    - 特殊目的陈述
        - [API Key](https://microservice-api-patterns.org/patterns/structure/specialPurposeRepresentations/APIKey) - How can an API provider identify and authenticate clients and their requests?
        - [Error Report](https://microservice-api-patterns.org/patterns/structure/specialPurposeRepresentations/ErrorReport)  - API 提供者如何通知其客户有关通信和处理错误的信息？ 如何使这些信息独立于底层通信技术和平台（例如，表示状态代码的协议级标头）？
        - [Context Representation](https://microservice-api-patterns.org/patterns/structure/specialPurposeRepresentations/ContextRepresentation)  - API 消费者和提供者如何在不依赖任何特定远程协议的情况下交换上下文信息？ 如何使请求中的身份信息和质量属性对会话中的相关后续对象可见？
- 质量
    - 参考管理        
        - [Embedded Entity](https://microservice-api-patterns.org/patterns/quality/referenceManagement/EmbeddedEntity) - 当接收者需要了解多个相关信息元素时，如何避免发送多条消息？
        - [Linked Information Holder](https://microservice-api-patterns.org/patterns/quality/referenceManagement/LinkedInformationHolder) - 即使 API 处理多个相互引用的信息元素，消息如何保持较小？
    - 数据传输简约        
        - [Pagination](https://microservice-api-patterns.org/patterns/quality/dataTransferParsimony/Pagination) - 即使 API 处理多个相互引用的信息元素，消息如何保持较小？
        - [Wish List](https://microservice-api-patterns.org/patterns/quality/dataTransferParsimony/WishList) - API 客户端如何在运行时通知 API 提供者它感兴趣的数据？
        - [Wish Template](https://microservice-api-patterns.org/patterns/quality/dataTransferParsimony/WishTemplate)  - API 客户端如何通知 API 提供者它感兴趣的嵌套数据？ 这种偏好如何灵活、动态地表达出来？
        - [Conditional Request](https://microservice-api-patterns.org/patterns/quality/dataTransferParsimony/ConditionalRequest) - 当频繁调用返回很少变化的数据的 API 操作时，如何避免不必要的服务器端处理和带宽使用？
        - [Request Bundle](https://microservice-api-patterns.org/patterns/quality/dataTransferParsimony/RequestBundle) - 如何减少请求和响应的数量以提高通信效率？

    - 质量管理和治理        
        - [Pricing Plan](https://microservice-api-patterns.org/patterns/quality/qualityManagementAndGovernance/PricingPlan) - API 提供者如何计量 API 服务消耗并对其收费？
        - [Rate Limit](https://microservice-api-patterns.org/patterns/quality/qualityManagementAndGovernance/RateLimit) - API 提供者如何防止 API 客户端过度使用 API？
        - [Service Level Agreement](https://microservice-api-patterns.org/patterns/quality/qualityManagementAndGovernance/ServiceLevelAgreement)  - API 客户端如何了解 API 及其端点操作的特定服务质量特征？ 如何以可衡量的方式定义和传达这些特征以及不满足这些特征的后果？

- 进化
    - [Version Identifier](https://microservice-api-patterns.org/patterns/evolution/VersionIdentifier) - API 提供者如何指示其当前功能以及对客户端可能不兼容的更改的存在，以防止由于未发现的解释错误导致客户端出现故障？
    - [Semantic Versioning](https://microservice-api-patterns.org/patterns/evolution/SemanticVersioning) - 利益相关者如何比较 API 版本以立即检测它们是否兼容？
    - [Two In Production](https://microservice-api-patterns.org/patterns/evolution/TwoInProduction) - 提供商如何在不破坏现有客户端的情况下逐步更新 API，同时又不必在生产中维护大量 API 版本？
    - [Aggressive Obsolescence](https://microservice-api-patterns.org/patterns/evolution/AggressiveObsolescence) - API 提供者如何在保证服务质量水平的情况下减少维护整个 API 或其部分（例如端点、操作或消息表示）的工作量？
    - [Experimental Preview](https://microservice-api-patterns.org/patterns/evolution/ExperimentalPreview) - 供应商如何才能在引入新 API 或新 API 版本的同时降低对客户的风险并获得早期采用者的反馈，而不必过早地冻结 API 设计？
    - [Limited Lifetime Guarantee](https://microservice-api-patterns.org/patterns/evolution/LimitedLifetimeGuarantee) - 提供商如何让客户知道他们可以依赖已发布的 API 版本多长时间？
    - [Eternal Lifetime Guarantee](https://microservice-api-patterns.org/patterns/evolution/EternalLifetimeGuarantee) - 提供商如何支持根本无法或不愿迁移到较新 API 版本的客户？

<!--lint disable-->
<!--lint enable-->
### SOA Patterns
 *SOA 模式是设计解决方案，为开发灵活且可重用的面向服务的应用程序提供指南和最佳实践. 这些模式解决了面向服务的应用程序设计的各个方面，包括服务标识、交互、组合和粒度. *
- 基础库存模式
   - [Canonical Protocol](https://patterns.arcitura.com/soa-patterns/design_patterns/canonical_protocol) - 定义服务之间的通用通信协议以实现互操作性和解耦.
   - [Canonical Schema](https://patterns.arcitura.com/soa-patterns/design_patterns/canonical_schema) - 定义用于在服务之间交换数据的标准数据模型和格式.
   - [Domain Inventory](https://patterns.arcitura.com/soa-patterns/design_patterns/domain_inventory) - 识别和分类特定域内的服务类型.
   - [Enterprise Inventory](https://patterns.arcitura.com/soa-patterns/design_patterns/enterprise_inventory) - 识别和分类特定域内的服务类型.
   - [Logic Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/logic_centralization) - 将业务逻辑集中在服务层中以减少冗余并提高一致性.
   - [Service Layers](https://patterns.arcitura.com/soa-patterns/design_patterns/service_layers) - 将业务逻辑集中在服务层中以减少冗余并提高一致性.
   - [Service Normalization](https://patterns.arcitura.com/soa-patterns/design_patterns/service_normalization) - 将业务逻辑集中在服务层中以减少冗余并提高一致性.

- 逻辑库存层模式
   - [Entity Abstraction](https://patterns.arcitura.com/soa-patterns/design_patterns/entity_abstraction) - 抽象数据实体以简化数据访问并减少耦合.
   - [Process Abstraction](https://patterns.arcitura.com/soa-patterns/design_patterns/process_abstraction) - 抽象流程以提高可重用性和可维护性.
   - [Utility Abstraction](https://patterns.arcitura.com/soa-patterns/design_patterns/utility_abstraction) - 抽象通用实用程序以减少重复并提高一致性.
   - [Micro Task Abstraction](https://patterns.arcitura.com/soa-patterns/design_patterns/micro_task_abstraction) - 将任务分解为更小、更细化的任务，以便于管理.

- 库存集中模式
   - [Policy Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/policy_centralization) - 集中策略以减少重复并提高一致性.
   - [Process Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/process_centralization) - 集中流程以提高可重用性和可维护性.
   - [Rules Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/rules_centralization) - 集中业务规则以减少重复并提高一致性.
   - [Schema Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/schema_centralization) - 集中数据模式以减少重复并提高一致性.

- 清单实施模式
   - [Canonical Resources](https://patterns.arcitura.com/soa-patterns/design_patterns/canonical_resources) - 为跨服务的通用功能定义一组标准资源.
   - [Cross-Domain Utility Layer](https://patterns.arcitura.com/soa-patterns/design_patterns/cross_domain_utility_layer) - 使用多种协议来提高性能和灵活性.
   - [Dual Protocols](https://patterns.arcitura.com/soa-patterns/design_patterns/dual_protocols) - 定义跨多个域的通用实用程序层.
   - [Inventory Endpoint](https://patterns.arcitura.com/soa-patterns/design_patterns/inventory_endpoint) - 定义用于访问库存资源的标准端点.
   - [Service Grid](https://patterns.arcitura.com/soa-patterns/design_patterns/service_grid) - 提供管理和扩展服务的框架.
   - [State Repository](https://patterns.arcitura.com/soa-patterns/design_patterns/state_repository) - 存储和管理服务状态信息.
   - [Stateful Services](https://patterns.arcitura.com/soa-patterns/design_patterns/stateful_services) - 跨服务调用维护状态信息.
   - [Augmented Protocols](https://patterns.arcitura.com/soa-patterns/design_patterns/augmented_protocols) - 通过附加功能增强协议.

- 库存治理模式
   - [Canonical Expression](https://patterns.arcitura.com/soa-patterns/design_patterns/canonical_expression) - 为库存数据定义标准表达语言.
   - [Canonical Versioning](https://patterns.arcitura.com/soa-patterns/design_patterns/canonical_versioning) - 为库存资源定义标准版本控制方案.
   - [Metadata Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/metadata_centralization) - 集中元数据以减少重复并提高一致性.

- 基础服务模式
   - [Agnostic Capability](https://patterns.arcitura.com/soa-patterns/design_patterns/agnostic_capability) - 抽象服务能力以提高灵活性.
   - [Agnostic Context](https://patterns.arcitura.com/soa-patterns/design_patterns/agnostic_context) - 抽象服务上下文以提高灵活性.
   - [Functional Decomposition](https://patterns.arcitura.com/soa-patterns/design_patterns/functional_decomposition) - 将服务分解为更小、更易于管理的组件.
   - [Non-Agnostic Context](https://patterns.arcitura.com/soa-patterns/design_patterns/non_agnostic_context) - 将服务分解为更小、更易于管理的组件.
   - [Service Encapsulation](https://patterns.arcitura.com/soa-patterns/design_patterns/service_encapsulation) - 封装服务功能以提高可维护性.

- 服务实施模式
   - [Partial State Deferral](https://patterns.arcitura.com/soa-patterns/design_patterns/partial_state_deferral) - 封装服务功能以提高可维护性.
   - [Partial Validation](https://patterns.arcitura.com/soa-patterns/design_patterns/partial_validation) - 仅验证相关数据以提高性能.
   - [Redundant Implementation](https://patterns.arcitura.com/soa-patterns/design_patterns/redundant_implementation) - 实现服务的多个版本以提高灵活性.
   - [Service Data Replication](https://patterns.arcitura.com/soa-patterns/design_patterns/service_data_replication) - 跨多个服务复制数据以提高性能.
   - [Service Façade](https://patterns.arcitura.com/soa-patterns/design_patterns/service_facade) - 为复杂服务提供简化的界面以提高可用性.
   - [UI Mediator](https://patterns.arcitura.com/soa-patterns/design_patterns/ui_mediator) - 在用户界面和底层服务之间进行调解以提高可用性.
   - [Reference Data Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/reference_data_centralization) - 集中参考数据以减少重复并提高一致性.
   - [Microservice Deployment](https://patterns.arcitura.com/soa-patterns/design_patterns/microservice_deployment) - 将服务部署为独立的自治单元，以提高可扩展性和弹性.
   - [Containerization](https://patterns.arcitura.com/soa-patterns/design_patterns/containerization) - 如何为具有高性能恢复和可扩展性要求的服务提供最大支持的环境？

- 服务安全模式
   - [Exception Shielding](https://patterns.arcitura.com/soa-patterns/design_patterns/exception_shielding) - 通过正确处理异常来防止安全漏洞.
   - [Message Screening](https://patterns.arcitura.com/soa-patterns/design_patterns/message_screening) - 筛选邮件中的恶意内容.
   - [Service Perimeter Guard](https://patterns.arcitura.com/soa-patterns/design_patterns/service_perimeter_guard) - 保护服务边界以防止未经授权的访问.
   - [Trusted Subsystem](https://patterns.arcitura.com/soa-patterns/design_patterns/trusted_subsystem) - 在子系统之间建立信任以提高安全性.

- 服务契约设计模式
   - [Concurrent Contracts](https://patterns.arcitura.com/soa-patterns/design_patterns/concurrent_contracts) - 允许多个版本的服务合同同时共存.
   - [Contract Centralization](https://patterns.arcitura.com/soa-patterns/design_patterns/contract_centralization) - 集中服务合同以提高一致性并减少重复.
   - [Contract Denormalization](https://patterns.arcitura.com/soa-patterns/design_patterns/contract_denormalization) - 集中服务合同以提高一致性并减少重复.
   - [Decoupled Contract](https://patterns.arcitura.com/soa-patterns/design_patterns/decoupled_contract) - 将服务合同与其实施分离以提高灵活性.
   - [Validation Abstraction](https://patterns.arcitura.com/soa-patterns/design_patterns/validation_abstraction) - 抽象验证逻辑以提高可重用性和可维护性.

- 遗留封装模式
   - [File Gateway](https://patterns.arcitura.com/soa-patterns/design_patterns/file_gateway) - Provides a gateway to access legacy file-based systems.
   - [Legacy Wrapper](https://patterns.arcitura.com/soa-patterns/design_patterns/legacy_wrapper) - 包装遗留系统以将它们公开为服务.
   - [Multi-Channel Endpoint](https://patterns.arcitura.com/soa-patterns/design_patterns/multi_channel_endpoint) - 提供多种通信渠道来访问遗留系统.

- 服务治理模式
   - [Compatible Change](https://patterns.arcitura.com/soa-patterns/design_patterns/compatible_change) - 在不破坏现有客户端的情况下启用对服务的更改.
   - [Decomposed Capability](https://patterns.arcitura.com/soa-patterns/design_patterns/decomposed_capability) - 将服务能力分解为更小、更易于管理的部分.
   - [Distributed Capability](https://patterns.arcitura.com/soa-patterns/design_patterns/distributed_capability) - 将服务能力分解为更小、更易于管理的部分.
   - [Proxy Capability](https://patterns.arcitura.com/soa-patterns/design_patterns/proxy_capability) - 提供代理到远程服务的能力，以提高性能并减少网络开销.
   - [Service Decomposition](https://patterns.arcitura.com/soa-patterns/design_patterns/service_decomposition) - 将整体服务分解为更小、更易于管理的部分.
   - [Service Refactoring](https://patterns.arcitura.com/soa-patterns/design_patterns/service_refactoring) - 重构服务以改进其设计和性能.
   - [Termination Notification](https://patterns.arcitura.com/soa-patterns/design_patterns/termination_notification) - 通知客户服务终止.
   - [Version Identification](https://patterns.arcitura.com/soa-patterns/design_patterns/version_identification) - 标识服务的版本. 

- 能力组合模式
   - [Capability Composition](https://patterns.arcitura.com/soa-patterns/design_patterns/capability_composition) - 结合多种服务能力创建新的能力.
   - [Capability Recomposition](https://patterns.arcitura.com/soa-patterns/design_patterns/capability_recomposition) - 重组现有服务能力以创建新能力.

- 服务消息模式
   - [Asynchronous Queuing](https://patterns.arcitura.com/soa-patterns/design_patterns/asynchronous_queuing) - 使用消息队列来解耦服务并提高可伸缩性和可靠性.
   - [Event-Driven Messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging) - 使用事件来触发服务调用并减少耦合.
   - [Intermediate Routing](https://patterns.arcitura.com/soa-patterns/design_patterns/intermediate_routing) - 使用中间路由节点来提高性能和灵活性.
   - [Messaging Metadata](https://patterns.arcitura.com/soa-patterns/design_patterns/messaging_metadata) - 使用元数据来描述和管理服务消息.
   - [Reliable Messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/reliable_messaging) - 确保分布式环境中的消息传递和可靠性.
   - [Service Agent](https://patterns.arcitura.com/soa-patterns/design_patterns/service_agent) - 充当远程服务的代理，以提高性能并减少网络开销.
   - [Service Callback](https://patterns.arcitura.com/soa-patterns/design_patterns/service_callback) - 使用回调在服务之间进行通信.
   - [Service Instance Routing](https://patterns.arcitura.com/soa-patterns/design_patterns/service_instance_routing) - 基于服务实例路由消息以提高性能和可扩展性.
   - [Service Messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/service_messaging) - 描述服务之间的通信.
   - [State Messaging](https://patterns.arcitura.com/soa-patterns/design_patterns/state_messaging) - 使用消息来管理分布式环境中的状态信息.

- 组合实现模式
   - [Agnostic Sub-Controller](https://patterns.arcitura.com/soa-patterns/design_patterns/agnostic_sub_controller) - 将子控制器与主控制器分离，以提高可重用性和可维护性.
   - [Atomic Service Transaction](https://patterns.arcitura.com/soa-patterns/design_patterns/atomic_service_transaction) - 使用事务来确保跨多个服务调用的原子性和一致性.
   - [Compensating Service Transaction](https://patterns.arcitura.com/soa-patterns/design_patterns/compensating_service_transaction) - 扭转失败交易的影响.
   - [Composition Autonomy](https://patterns.arcitura.com/soa-patterns/design_patterns/composition_autonomy) - 使服务能够在组合中自主运行.

- 服务交互安全模式
   - [Brokered Authentication](https://patterns.arcitura.com/soa-patterns/design_patterns/brokered_authentication) - 通过代理对客户端进行身份验证.
   - [Data Confidentiality](https://patterns.arcitura.com/soa-patterns/design_patterns/data_confidentiality) - 确保分布式环境中的数据机密性.
   - [Data Origin Authentication](https://patterns.arcitura.com/soa-patterns/design_patterns/data_origin_authentication) - 验证消息的来源.
   - [Direct Authentication](https://patterns.arcitura.com/soa-patterns/design_patterns/direct_authentication) - 直接验证客户端.

- Transformation Patterns
   - [Data Format Transformation](https://patterns.arcitura.com/soa-patterns/design_patterns/data_format_transformation) - 转换数据格式以实现互操作性.
   - [Data Model Transformation](https://patterns.arcitura.com/soa-patterns/design_patterns/data_model_transformation) - 转换数据模型以实现互操作性.
   - [Protocol Bridging](https://patterns.arcitura.com/soa-patterns/design_patterns/protocol_bridging) - 不同协议之间的桥梁以实现互操作性.

- 受 REST 启发的模式
   - [Entity Linking](https://patterns.arcitura.com/soa-patterns/design_patterns/entity_linking) - 链接相关资源以启用导航和发现.
   - [Lightweight Endpoint](https://patterns.arcitura.com/soa-patterns/design_patterns/lightweight_endpoint) - 为资源访问提供轻量级端点.
   - [Reusable Contract](https://patterns.arcitura.com/soa-patterns/design_patterns/reusable_contract) - 重用通用合同以提高一致性并减少重复.
   - [Content Negotiation](https://patterns.arcitura.com/soa-patterns/design_patterns/content_negotiation) - 协商客户端和服务器之间的内容格式.
   - [Endpoint Redirection](https://patterns.arcitura.com/soa-patterns/design_patterns/endpoint_redirection) - 将客户端重定向到替代端点.
   - [Idempotent Capability](https://patterns.arcitura.com/soa-patterns/design_patterns/idempotent_capability) - 确保可以在不更改系统状态的情况下多次执行相同的操作.

<!--lint disable-->
<!--lint enable-->
## Resources
*一些有用的规范、标准、文章和文档.*
### API Specification
- [API Blueprint](https://github.com/apiaryio/api-blueprint) - 一种功能强大的高级语言，用于设计和记录 API，使软件工程师能够轻松协作并创建高效的 API.
- [AsyncAPI](https://github.com/asyncapi/spec) - 开发事件驱动架构 (EDA) 的重要工具，使工程师能够构建更好的工具生态系统.
- [GraphQL](https://github.com/graphql/graphql-spec) - 用于构建高效 API 的复杂查询语言和运行时，使工程师能够轻松地从现有系统检索数据.
- [JSON:API](https://github.com/json-api/json-api) - 用于构建 API 的标准化规范，简化了资源、关系和元数据的表示，使软件工程师更容易创建高效的 API.
- [OpenAPI (ex.Swagger)](https://github.com/OAI/OpenAPI-Specification) - 一种与语言无关的规范，用于创建 RESTful API，使人和机器都能理解服务的功能，而无需源代码或文档.
- [RAML](https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/) - 一种 RESTful API 建模语言，允许软件工程师通过对资源、端点和交互进行建模来设计和创建高效的 API.
- [WSDL](http://www.w3.org/TR/wsdl20) - 用于基于 SOAP 的服务的强大的基于 XML 的接口描述语言，使软件工程师能够描述 Web 服务的功能并自动创建客户端代码.

<!--lint disable-->
<!--lint enable-->
### Articles
- [Enterprise Integration Using REST](http://martinfowler.com/articles/enterpriseREST.html) - 讨论非公共 API 的限制和灵活性，以及​​从跨多个团队进行大规模 RESTful 集成中吸取的经验教训.
- [Richardson Maturity Model](http://martinfowler.com/articles/richardsonMaturityModel.html) - 由 Martin Fowler 解释，最初由 Leonard Richardson 提出.

<!--lint disable-->
<!--lint enable-->
### Certifications
<details>
<summary>API学院</summary>
  
- [API Designer](https://apiacademy.learnupon.com/) - 验证您对 API 设计基础知识和最佳实践的理解.
- [API Product Manager](https://apiacademy.co/2020/05/virtual-api-academy-workshop/) - 展示您在将 API 作为产品进行管理方面的熟练程度.
- [API Security Architect](https://apiacademy.co/api-certification/) - 验证您在使用现代架构保护 API 方面的专业知识.
  
</details>
<details>
<summary>Boomi</summary>
  
- [Associate Administrator Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIKWA2&ltui__urlRedirect=learning-plan-detail-standard) - 验证个人在管理 Boomi 平台方面的基础知识和技能，重点是平台监控、故障排除和安全性.
- [Associate Developer Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIeWAM&ltui__urlRedirect=learning-plan-detail-standard) - 展示候选人对使用 Boomi 平台构建和部署集成流程的基本理解，包括设计模式、部署和错误处理.
- [Associate EDI for X12 Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIFWA2&ltui__urlRedirect=learning-plan-detail-standard) - 验证个人使用 Boomi 设计、开发和管理电子数据交换 (EDI) 与 X12 标准集成的熟练程度，涵盖 EDI 文档结构和贸易伙伴管理等基本概念.
- [Associate Flow Essentials Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIZWA2&ltui__urlRedirect=learning-plan-detail-standard) - 展示候选人使用 Boomi Flow 创建和管理业务应用程序的知识，重点是工作流设计、用户界面和数据集成.
- [Associate Master Data Hub Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIPWA2&ltui__urlRedirect=learning-plan-detail-standard) - 强调候选人对使用 Boomi Master Data Hub 确保数据质量和跨系统一致性的理解，重点是数据建模、治理和同步.
- [Development and Application Architecture Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OJOWA2&ltui__urlRedirect=learning-plan-detail-standard) - 确认个人在 Boomi 平台上设计和实施复杂集成解决方案和应用程序架构方面的专业知识，包括最佳实践和性能优化.
- [Professional API Design Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OKzWAM&ltui__urlRedirect=learning-plan-detail-standard) - 展示候选人使用 Boomi 设计、开发和管理 API 的能力，包括 RESTful API 原则、API 安全性和版本控制.
- [Professional API Management Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIyWAM&ltui__urlRedirect=learning-plan-detail-standard) - 验证个人在使用 Boomi 平台管理 API 的整个生命周期方面的专业知识，包括 API 部署、监控和分析.
- [Professional Developer Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OJrWAM&ltui__urlRedirect=learning-plan-detail-standard) - 认可候选人在使用 Boomi 开发、部署和管理集成流程方面的深入知识和技能，重点是高级数据转换和错误处理技术.
- [Professional Flow Developer Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIUWA2&ltui__urlRedirect=learning-plan-detail-standard) - 展示个人使用 Boomi Flow 设计、开发和管理业务应用程序的高级能力，包括复杂的工作流设计、自定义 UI 组件以及与外部系统的集成.
- [Professional Linux Operational Administrator Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OI5WAM&ltui__urlRedirect=learning-plan-detail-standard) - 确认候选人在 Linux 系统上管理和管理 Boomi 的熟练程度，涵盖系统安装、配置、安全和性能优化等主题.
- [Professional Windows Operational Administrator Certification](https://community.boomi.com/s/learning-plan-detail-standard?ltui__urlRecordId=aOM6S0000008OIAWA2&ltui__urlRedirect=learning-plan-detail-standard) - 验证个人在 Windows 系统上管理和管理 Boomi 的专业知识，重点是系统安装、配置、安全性和性能优化.
  
</details>
<details>
<summary>IBM</summary>
  
- [IBM Certified Solution Developer – App Connect Enterprise V11](https://www.ibm.com/training/certification/C0003107#exam) - 验证您使用 IBM App Connect V11.0 开发、部署、调整和支持独立于平台的消息流应用程序的中级知识和经验.
- [IBM Certified Solution Implementer – API Connect v10.0.3](https://www.ibm.com/training/certification/C0002604#exam) - 展示您使用 IBM API Connect v10.0.3 开发、发布、配置和管理 API 的中级知识和技能.

</details>
<details>
<summary>Gravitee</summary>

- [Event-native API Management Foundations](https://gravitee.getlearnworlds.com/course/gravitee-event-native-api-management-foundations) - 事件原生 API 管理基础.
- [Event-native API Management Professional](https://gravitee.getlearnworlds.com/course/gravitee-enap-certification) - 专注于一些更高级的 API 管理概念，以及有关如何使用 Gravitee API 管理的基础知识.
  
</details>
<details>
<summary>Kong</summary>
  
- [Kong Gateway Certified Associate](https://konghq.com/academy/exam-preparation) - 为开发人员、DevOps 和架构师验证您在 Kong Gateway 上的入门级知识和技能.

</details>
<details>
<summary>Mulesoft</summary>
  
- [MuleSoft Certified Developer - Level 1](https://training.mulesoft.com/certification/developer-mule4-level1) - 验证您使用 MuleSoft 设计、构建、测试和调试、部署和管理基本 API 和集成的知识和技能.
- [MuleSoft Certified Developer - Level 2](https://training.mulesoft.com/certification/developer-mule4-level2) - 验证您在生产就绪的 Mule 应用程序上工作的能力，这些应用程序可以解决和平衡关键的非功能性需求，包括监控、性能、可维护性、可靠性和安全性.
- [MuleSoft Certified Integration Architect - Level 1](https://training.mulesoft.com/certification/architect-integration-level1) - 验证您将功能和非功能需求转化为集成接口和实现的知识和技能.
- [MuleSoft Certified Platform Architect - Level 1](https://training.mulesoft.com/certification/architect-platform-level1) - 验证您的知识和技能，以使用 Anypoint Platform 在整个组织中使用 API 主导的连接后，从单个集成解决方案中引导有效应用程序网络的出现.

</details>
<details>
<summary>Oracle</summary>

- [Oracle Business Process Management Suite 12c Certified Implementation Specialist](https://education.oracle.com/oracle-business-process-management-suite-12c-essentials/pexam_1Z0-435) - 验证您在实施 Oracle BPM Suite 12c 解决方案方面的专业知识.
- [Oracle Cloud Platform Application Integration 2022 Certified Professional](https://education.oracle.com/oracle-cloud-platform-application-integration-2022-certified-professional/trackp_OCPAI2022CP) - Validate your understanding of Oracle Application Integration to implement these Cloud services.
- [Oracle Data Integrator 12c Certified Implementation Specialist](https://education.oracle.com/oracle-data-integrator-12c-certified-implementation-specialist/trackp_379) - 验证您在销售或实施 Oracle Data Integration 12c 解决方案方面的专业知识.
- [Oracle SOA Suite 12c Certified Implementation Specialist](https://education.oracle.com/oracle-soa-suite-12c-essentials/pexam_1Z0-434) - 验证您在实施基于 Oracle SOA Suite 12c 的解决方案方面的专业知识.

</details>
<details>
<summary>红帽</summary>
 
- [Red Hat Certified Specialist in API Management](https://www.redhat.com/en/services/certification/red-hat-certified-specialist-api-management) - 验证使用 Red Hat 3scale API 管理平台创建和维护企业 API 的能力.
- [Red Hat Certified Specialist in Business Rules](https://www.redhat.com/en/services/certification/rhcs-business-rules) - 检查使用红帽 JBoss BRMS 执行涉及业务逻辑实施和管理的任务所需的知识、技能和能力.
- [Red Hat Certified Specialist in Cloud-native Integration](https://www.redhat.com/en/services/certification/rhcs-cloud-native-integration) - 验证基于 Red Hat Fuse、Camel 和 API 创建和维护企业集成服务的能力.
- [Red Hat Certified Specialist in Event-Driven Development with Kafka](https://www.redhat.com/en/services/certification/red-hat-certified-specialist-event-driven-development-kafka) - 验证使用 Apache Kafka 和 Apache Kafka Streams 开发应用程序的能力.
  
</details>
<details>
<summary>SnapLogic</summary>

- [SnapLogic Administrator Certification](https://learn.snaplogic.com/snaplogic-administrator-certification) - 评估您处理 SnapLogic 实例管理任务的能力.
- [SnapLogic Architect Certification](https://learn.snaplogic.com/snaplogic-architect-certification) - 评估您对 SnapLogic 平台的集成参考架构和关键策略的了解，涵盖的主题包括 SnapLogic 架构、Snaplex 要求、管道生命周期管理、高级数据转换、API 管理、可恢复管道和最佳实践.
- [SnapLogic Certified Enterprise Automation Professional](https://learn.snaplogic.com/snaplogic-certified-automation-professional) - 一项高级认证，涵盖 SnapLogic 平台、资产管理、工作流、表达语言、任务、管道模块化、迁移和各种端点的用户帮助视频等主题.
- [SnapLogic Developer Certification](https://learn.snaplogic.com/snaplogic-developer-certification) - 测试您在使用 SnapLogic SDK、实现 Snap 功能的不同部分以及构建自定义 Snap 方面的专业知识.
- [SnapLogic Integrator Certification](https://learn.snaplogic.com/snaplogic-integrator-certification-1) - 专注于初学者培训、超任务、管道迁移和涵盖各种集成端点的用户帮助视频等主题.

</details>
<details>
<summary>TIBCO</summary>

- [TIBCO BusinessWorks Associate](https://www.tibco.com/services/education/certification/tibco-businessworks-associate-certification-exam) - 检查对 Business Studio 和 TIBCO Cloud Integration 的理解、设计应用程序组件（模块、WSDL、REST API）、开发集成应用程序以及测试、部署和管理应用程序.
- [TIBCO BusinessWorks Certified Professional](https://www.tibco.com/services/education/certification/tibco-businessworks-6-certification-exam) - 验证在最少监督下设计、开发、部署、监控和管理中等复杂度的 TIBCO BusinessWorks 应用程序的能力.
- [TIBCO BusinessWorks Container Edition Certified Professional](https://www.tibco.com/services/education/certification/tibco-businessworks-container-edition-certification-exam) - 验证在最少监督下开发、部署和管理中等复杂度的 TIBCO BusinessWorks Container Edition 应用程序的能力.
- [TIBCO BPM Enterprise Associate](https://www.tibco.com/services/education/certification/tibco-bpm-enterprise-associate-certification-exam) - 检查对 TIBCO BPM 特性和功能的理解，开发和管理业务流程，以及部署和测试流程应用程序.
- [TIBCO BPM Enterprise Certified Professional](https://www.tibco.com/services/education/certification/tibco-bpm-enterprise-5-certification-exam) - 验证使用 TIBCO BPM Enterprise Suite 设计、开发、部署和管理业务流程的能力.
- [TIBCO Cloud Associate Certification](https://www.tibco.com/services/education/certification/tibco-cloud-associate-certification-exam) - 验证使用 TIBCO Cloud 所需的技能和知识，包括其关键组件和功能.
- [TIBCO Cloud API Management Associate](https://www.tibco.com/services/education/certification/tibco-mashery-associate-certification-exam) - 涵盖 API 定义创建和测试、API 密钥身份验证以及使用 Developer Portal 和 I/O 文档等主题.
- [TIBCO Cloud API Management Certified Professional](https://www.tibco.com/services/education/certification/tibco-cloud-api-management-professional-certification-exam) - 验证实施 TIBCO Cloud Mesh、基于 OAuth 的安全性和管理 SOAP 服务的能力.
- [TIBCO Cloud Integration Associate](https://www.tibco.com/services/education/certification/tibco-cloud-integration-associate-certification-exam) - 验证使用 TIBCO Cloud Integration 所需的技能和知识，包括其连接、开发和集成功能.
- [TIBCO Cloud Integration - Connect Associate](https://www.tibco.com/services/education/certification/tibco-cloud-integration-connect-associate-certification-exam) - 检查 TIBCO Cloud Integration 的 Connect 功能的使用情况、安装 On-Premise Agent、创建连接和集成应用程序以及配置流程.
- [TIBCO Cloud Integration - Connect Certified Professional](https://www.tibco.com/services/education/certification/tibco-cloud-integration-connect-certified-professional-exam) - 检查连接的创建和管理，确保连接安全，并解决与 TIBCO Cloud Integration 中的连接相关的问题.
- [TIBCO Cloud Integration Certified Professional](https://www.tibco.com/services/education/certification/tibco-cloud-integration-certified-professional-exam) - 检查有关功能和优势、集成、开发和连接应用程序、使用 API Modeler 和 Mock 功能创建 API 等方面的知识.
- [TIBCO Messaging Associate](https://www.tibco.com/services/education/certification/tibco-messaging-associate-certification-exam) - 涵盖 TIBCO Enterprise Message Service (EMS)、TIBCO FTL、TIBCO eFTL 等主题，以及 Apache Kafka、Apache Pulsar 和 Eclipse Mosquitto 等其他消息传递技术.
- [TIBCO Messaging Certified Professional](https://www.tibco.com/services/education/certification/tibco-messaging-certified-professional-exam) - 验证使用 TIBCO Messaging 及其组件所需的技能和知识，包括 TIBCO Enterprise Message Service (EMS)、TIBCO FTL 和 TIBCO eFTL.
  
</details>

<!--lint disable-->
<!--lint enable-->

### Connectors
- [JCA](https://projects.eclipse.org/projects/ee4j.jca)  - 为 Jakarta EE 应用程序组件定义标准架构以连接到企业信息系统. 以前称为 Java EE 连接器体系结构和 J2EE 连接器体系结构.
- [Kafka Connect](https://kafka.apache.org/documentation/#connect) - 一种用于在 Apache Kafka 和其他系统之间可扩展且可靠地传输数据的工具.

<!--lint disable-->
<!--lint enable-->
### Data Formats
- [Apache Avro](https://github.com/apache/avro)  - 数据序列化系统，提供紧凑、快速、高效的结构化数据序列化. 它支持模式演进，允许高效的数据压缩，并且旨在与大数据处理框架很好地配合使用.
- [BSON](https://bsonspec.org/)  - 用于类似 JSON 的文档的二进制编码序列化格式，旨在轻量级和高效. 它支持丰富的数据类型，广泛应用于NoSQL数据库，如MongoDB.
- [CSV](https://datatracker.ietf.org/doc/html/rfc4180)  - 一种简单且广泛使用的数据格式，以纯文本形式存储表格数据. 它易于读写，可以被大多数编程语言处理.
- [JSON](https://datatracker.ietf.org/doc/html/rfc8259)  - 一种广泛用于数据交换的轻量级且易于阅读的数据格式. 它支持广泛的数据类型，并与许多编程语言兼容.
- [NDJSON](https://github.com/ndjson/ndjson-spec)  - 在流协议中分隔 JSON 对象的标准. 它允许高效处理大型 JSON 数据集，并广泛用于大数据处理.
- [Protocol Buffers](https://github.com/protocolbuffers/protobuf)  - 一种语言中立和平台中立的序列化机制，旨在高效和可扩展. 支持丰富的数据类型，广泛应用于分布式系统，如gRPC、Apache Kafka等.
- [XML](https://www.w3.org/TR/2006/REC-xml11-20060816/)  - 一种灵活且广泛使用的标记语言，用于存储和交换结构化数据. 它支持丰富的数据类型，兼容多种编程语言.
- [YAML](https://yaml.org/)  - 一种人性化且易于阅读的数据序列化格式，广泛用于配置文件和数据交换. 它支持丰富的数据类型，兼容大多数编程语言.

<!--lint disable-->
<!--lint enable-->
### Integration Styles
- [File Transfer](https://www.enterpriseintegrationpatterns.com/patterns/messaging/FileTransferIntegration.html) - 数据通过应用程序之间的文件交换进行交换.
- [Messaging](https://www.enterpriseintegrationpatterns.com/patterns/messaging/Messaging.html) - Applications exchange messages using a messaging infrastructure.
- [Remote Procedure Invocation](https://www.enterpriseintegrationpatterns.com/patterns/messaging/EncapsulatedSynchronousIntegration.html) - 应用程序通过网络调用远程服务器上的函数或过程.
- [Shared Database](https://www.enterpriseintegrationpatterns.com/patterns/messaging/SharedDataBaseIntegration.html) - Multiple applications access and manipulate the same data through a common database.

<!--lint disable-->
<!--lint enable-->
### Market Analysis
- API Management
  - [Gartner Critical Capabilities for Full Life Cycle API Management](https://www.gartner.com/doc/code/468184)
  - [Gartner Magic Quadrant for Full Life Cycle API Management](https://www.gartner.com/doc/code/464116)
  - [The Forrester Wave: API Management Solutions](https://www.forrester.com/go?objectid=RES159081)
- BPM
  - [Gartner Critical Capabilities for Intelligent Business Process Management Suites](https://www.gartner.com/doc/code/292486)
  - [Gartner Magic Quadrant for Intelligent Business Process Management Suites](https://www.gartner.com/doc/code/345694)
-ETL
  - [Gartner Critical Capabilities for Data Integration Tools](https://www.gartner.com/doc/code/464068)
  - [Gartner Magic Quadrant for Data Integration Tools](https://www.gartner.com/doc/code/450251)
- iPaaS
  - [Gartner Critical Capabilities for Enterprise Integration Platform as a Service](https://www.gartner.com/doc/code/434187)
  - [Gartner Magic Quadrant for Enterprise Integration Platform as a Service](https://www.gartner.com/doc/code/397953)
  - [The Forrester Wave: Enterprise iPaaS](https://www.forrester.com/report/the-forrester-wave-tm-enterprise-ipaas-q4-2021/RES176201)
- 机器人流程自动化
  - [Gartner Critical Capabilities for Robotic Process Automation](https://www.gartner.com/doc/code/465756)
  - [Gartner Magic Quadrant for Robotic Process Automation](https://www.gartner.com/doc/code/441474)
  - [The Forrester Wave: Robotic Process Automation](https://www.forrester.com/go?objectid=RES161538)

<!--lint disable-->
<!--lint enable-->
### Protocols
- [AMQP 0-9-1](https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf)  - 一种消息队列协议，支持在应用程序或系统之间交换消息.  AMQP 0-9-1 提供可靠性、安全性和灵活性来处理复杂的消息传递场景.
- [AMQP 1.0](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-overview-v1.0-os.html)  - 一种广泛接受的消息队列协议，可在系统之间提供可靠、可互操作且高效的消息传递.  AMQP 1.0 支持广泛的消息传递场景，非常适合复杂的企业级应用程序.
- [CoAP](http://coap.technology/)  - 专门为物联网 (IoT) 生态系统中的受限设备设计的应用程序协议.  CoAP 提供了一种轻量级、低开销的通信机制来支持资源受限的设备.
- [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)  - 一种广泛使用的协议，可促进 Web 服务器和客户端之间的通信.  HTTP 支持通过 Internet 传输数据，从而使 Web 应用程序可以无缝运行.
- [JSON-RPC](https://www.jsonrpc.org/specification)  - 一种简单轻量级的远程过程调用协议，支持使用 JSON 数据在系统之间进行通信.  JSON-RPC 提供无状态通信，适用于资源受限的设备.
- [MQTT](https://mqtt.org/mqtt-specification/)  - 一种轻量级高效的发布-订阅协议，支持设备间的消息传递.  MQTT 支持低开销通信，是物联网和移动应用程序的理想选择.
- [SOAP](https://www.w3.org/TR/soap/)  - 使用 XML 实现系统间通信的消息传递协议.  SOAP 支持广泛的消息传递方案，包括分布式计算和企业应用程序.
- [STOMP](https://stomp.github.io/)  - 一种消息传递协议，在系统之间提供简单的、面向文本的通信.  STOMP 是低延迟、高性能消息传递场景的理想选择.

<!--lint disable-->
<!--lint enable-->
### Standard APIs
- [JDBC](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/)  - 基于 Java 的 API，提供对关系数据库的通用数据访问.  JDBC 提供了一种一致且高效的方式来访问和操作数据，使其成为开发人员的热门选择.
- [JMS](https://javaee.github.io/jms-spec/)  - 使 Java 应用程序能够发送和接收消息的消息传递 API.  JMS 支持可靠的消息传递，广泛应用于企业级应用程序.
- [ODBC](https://docs.microsoft.com/en-us/sql/odbc/reference/odbc-overview)  - 一种被广泛接受的 API，它提供了一种标准化的方式来访问来自各种数据库管理系统的数据.  ODBC 提供一致的接口来访问数据，使开发数据库应用程序变得容易.
- [OData](https://www.odata.org/)  - 一种开放协议，支持创建和使用可查询和可互操作的 REST API.  OData 简化了 REST API 的开发，并提供了一种标准化的数据访问方式.

<!--lint disable-->
<!--lint enable-->
### Structure and Validation
- [JSON Schema](https://json-schema.org/)  - 用于验证 JSON 数据结构的强大工具.  JSON Schema 使开发人员能够确保 JSON 数据符合特定的结构，使其更易于处理和操作.
- [Schematron](https://www.schematron.com)  - 一种基于规则的验证语言，使开发人员能够定义和验证业务规则、数据报告、质量控制和其他验证场景.  Schematron 提供了一种灵活的方法来验证 XML 文档.
- [XML Schema](https://www.w3.org/TR/xmlschema11-1/)  - 一种模式语言，它提供了描述结构和限制 XML 文档内容的工具.  XML Schema 使开发人员能够确保 XML 数据符合特定的结构，使其更易于处理和操作.

<!--lint disable-->
<!--lint enable-->
## Contributing
随时欢迎您的贡献！ 请看一下 [contribution guidelines](https://github.com/stn1slv/awesome-integration/blob/main/CONTRIBUTING.md) 第一的.
